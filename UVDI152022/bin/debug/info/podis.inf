;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; !!!    아래 환경 파일 작성 순서는 아래와 같이 반드시 순서를 지켜야 됨. 임의로 옮기면 안됨    !!!
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;-------------------------------------------------------------------------------------------------
; [COMMON]
;
; SW_TITLE              = Engine에서 사용하지 않음. (단지 환경 파일 구분 용도 목적임)
;
; RUN_DEVELOPE_MODE     = 0 : 사용자 모드, 1 : 개발자 모드
; RUN_EMULATE_MODE      = 0 : 실제 장비와 연동 후 동작, 1 : 장비 연결 없이 SW 내부적으로 동작
;
; RUN_ENGINE_MONITOR    = 0 : 엔진 내부 데이터 모니터링 프로그램 실행하지 않기
;                         1 : 엔진 내부 데이터 모니터링 프로그램 실행하기
; RUN_MATERIAL_DETECT   = 소재 감지 여부. (0:소재 유무 감지 없이 노광 진행, 1:소재 감지 확인 후 노광)
;                         단, Align Expose인 경우만 해당됨
; LOG_FILE_SAVED        = 0 : 로그 파일로 저장 안함, 1 : 로그 파일로 저장 함
;
; GRAB_MARK_SAVED       = 검색된 얼라인 마크 저장 유무. (검색 실패와 상관 없이 무조건 저장 유무)
;                         GUI (제어SW)가 실행된 폴더에서 mark 라는 하위 폴더에 저장됨
;
; GERBER_PATH           = 거버가 저장되어 있는 기본 경로 (Full Path)
;                         GUI (제어SW)에서 거버 선택하려고 폴더 선택 대화상자 띄울 때,
;                         이 경로 기준으로 선택하면, 좀더 빠르게 접근 가능하도록 하기 위함
;                         또는 이 폴더 이외에 다른 폴더의F 거버를 선택할 때, 에러 체크 용도로 사용함
; PREPROC_DLL_PATH      = PreProcess 동작과 관련된 DLL 파일들이 저장되어 있는 경로 (!!! 중요 !!!)
;
; STROBE_LAMP_TYPE      = 채널 당 조명 2개 사용 가능 (단, 동시에 2개 사용은 불가능)
;                         0 : 조명 1번 (Lamp: Coxial), 1 : 조명 2번 (Lamp: Ring)
; ALIGN_CAMERA_KIND     = PODIS에서 제공하는 카메라의 종류 선택
;                         0 : None, 1 : Basler (외부), 2 : IDS (VISITECH; 내장)
; ALL_ALARM_IGNORE      = DI 장비에서 발생되는 모든 알람 무시 여부 (1:무시, 0:알림)
;                         다만 장비 연결 여부는 체크 함 (연결안되면 알람 발생)
; ALL_WARN_IGNORE       = DI 장비에서 발생되는 모든 경고 무시 여부 (1:무시, 0:알림)
;
;
; COMM_LOG_OPTIC        = 통신 드라이브를 통해 <송수신>된 로그 이력 남기기
; COMM_LOG_MC2          = 통신 드라이브를 통해 <송수신>된 로그 이력 남기기 (수동 요청된 경우만 저장)
; COMM_LOG_PLC          = 통신 드라이브를 통해 <설정>된 로그 이력 남기기 (설정 요청된 경우만 저장)
; COMM_LOG_EFU          = 통신 드라이브를 통해 <송수신>된 로그 이력 남기기
; COMM_LOG_MILARA       = 통신 드라이브를 통해 <송수신>된 로그 이력 남기기 (Robot & Prealigner)
; COMM_LOG_PM100D       = 통신 드라이브를 통해 <송수신>된 로그 이력 남기기
; COMM_LOG_LITHO        = 통신 드라이브를 통해 <변경>된 로그 이력 남기기
;
; MESG_BOX_OPTIC        = Engine 내부 중 광학계에서 발생된 에러를 메시지 박스로 출력 여부
;
;-------------------------------------------------------------------------------------------------

[COMMON]

SW_TITLE                = CMPS for SKC Demo

; 2022-03-18 (PODIS for SKC)
GERBER_PATH             = d:\Gerber\2.4.0\LLS10\HEAD_2
PREPROC_DLL_PATH        = c:\Luria\PreProcess

RUN_DEVELOPE_MODE       = 0
RUN_EMULATE_MODE        = 0
RUN_ENGINE_MONITOR      = 0
RUN_MATERIAL_DETECT     = 0
LOG_FILE_SAVED          = 1
GRAB_MARK_SAVED         = 1
STROBE_LAMP_TYPE        = 1
ALIGN_CAMERA_KIND       = 1
ALL_ALARM_IGNORE        = 1
ALL_WARN_IGNORE         = 0

COMM_LOG_OPTIC          = 0
COMM_LOG_MC2            = 0
COMM_LOG_PLC            = 0
COMM_LOG_EFU            = 0
COMM_LOG_MILARA         = 0
COMM_LOG_PM100D         = 0
COMM_LOG_LITHO          = 0

MESG_BOX_OPTIC          = 0
LOG_FILE_TYPE= 0

;-------------------------------------------------------------------------------------------------
; [MONITOR]
;
; !!! 아래 3개의 변수는 프로그램 (모니터링 프로그램 제외)이 실행될 때, 초기화 됨 !!!
;
; START_TIME            = 가장 최근에 모니터링 시작한 시간 (년,월,일,시,분,초)
; ERROR_COUNT           = 모니터링 시작한 시간 기준으로 발생된 에러 개수 (최대 개수: 65535)
; WARN_COUNT            = 모니터링 시작한 시간 기준으로 발생된 경고 개수 (최대 개수: 65535)
;
; HDD_DRIVE             = HDD 용량 모니터링 드라이브 인덱스 (0:C, 1:D, 2:E, 3:F, 4:G, 5:H, ..., )
;-------------------------------------------------------------------------------------------------

[MONITOR]

START_TIME              = 2023-06-10 15:09:03
ERROR_COUNT             = 0
WARN_COUNT              = 0

HDD_DRIVE               = 1

;-------------------------------------------------------------------------------------------------
; [COMMUNICATION]
;
; CMPS_IPv4 (Client) vs. SVC_IPv4  (Server)
; CMPS_IPv4 (Client) vs. MC2_IPv4  (Server)
; CMPS_IPv4 (Client) vs. PLC_IPv4  (Server)
; CMPS_IPv4 (Client) vs. TRIG_IPv4 (Server)
;
; LINK_TIME             = The cycle to reconnnect to system server (unit: millisecond)
;                         (If 0, do not use, 최소 값으로 3000 이사이어야 함)
; IDLE_TIME             = 현재 설정된 시간 동안 통신 응답이 없는 경우, 연결 해제 (unit: ms)
;                         (If 0, do not use / 최소 값으로 3000 이상이어야 함)
;                         Client sends Alive Check message to the server whether communication is alive
;                         (If 0, do not use)
; LIVE_TIME             = 현재 설정된 시간 마다 Live Check 메시지 송신 (unit: ms, Normal:0 or 5000)
;                         (If 0, do not use / 최소 값으로 1000 이상이어야 함)
;                         (현재 CMPS와 EFEM 장비하고만 사용됨)
; SOCK_TIME             = 소켓 수신 이벤트 감지 간격 (unit: ms, Normal:0, 0 값은 실시간 감지)
;
; CMPS_IPv4             = CMPS Client IP Address
; SVC_IPv4              = Optic. (Service) Server IP Address
; MC2_IPv4              = Motion Server IP Address
; PLC_IPv4              = PLC (Melsec Q) Server IP Address
; TRIG_IPv4             = Trigger Board Server IP Address
;
; SVC_PORT              = Optic Service (Server) 와 통신하는 포트 번호
; MC2S_PORT             = UDP 패킷을 MC2쪽으로 송신하는 포트 번호
; MC2C_PORT             = UDP 패킷을 MC2로부터 수신받는 포트 번호
; PLC_PORT              = Melsec Q PLC와 통신하는 포트 번호
; TRIG_PORT             = Trigger Board와 통신하는 포트 번호
;
; PORT_BUFF             = 송/수신 버퍼 크기 (unit: KBytes, Min:128)
; RECV_BUFF             = 한번 수신된 데이터가 저장될 임시 버퍼 크기 (unit: KBytes, Min:512)
; RING_BUFF             = 수신된 패킷들이 저장될 임시 링 버퍼 크기 (unit: KBytes, Min:1024)
;                         !!! 적어도 'RECV_BUFF' 버퍼보다 2배 이상 커야 됨 !!!
;-------------------------------------------------------------------------------------------------

[COMMUNICATION]

CMPS_IPv4               = 100.100.100.43
SVC_IPv4                = 100.100.100.41
MC2_IPv4                = 100.100.100.11
PLC_IPv4                = 100.100.100.10
TRIG_IPv4               = 100.100.100.243
EFEM_IPv4               = 100.100.100.30

PLC_PORT                = 9922
EFEM_PORT               = 9992
TRIG_PORT               = 9993
MC2S_PORT               = 13827
MC2C_PORT               = 13831
SVC_PORT                = 55900

LINK_TIME               = 5000
IDLE_TIME               = 5000
SOCK_TIME               = 0
LIVE_TIME               = 0

PORT_BUFF               = 256
RECV_BUFF               = 1024
RING_BUFF               = 2048

;-------------------------------------------------------------------------------------------------
; [PH_SERVICE]
;
; OPTIC_VER_MAJOR           = 광학계 서비스 SW version : 반드시 정수 (1,2,3,4,....)
; OPTIC_VER_MINOR           = 광학계 서비스 SW version : 반드시 정수 (4,5,7,11,)
; OPTIC_VER_BUILD           = 광학계 서비스 SW version : 반드시 정수 (4432,5421,7123,1121,)
;                             ex> 2.4.5166  -> major = 2, minor = 4, build=5155
;                                 2.11.4455 -> major = 2, minor = 11, build=4455 (반드시 규칙 지킬것)
; TABLE_COUNT               = Work Table 개수 (만약 Double Stage이면 2)
; TOTAL_PH                  = 장비에 설치된 포토헤드 개수 (1 ~ 8)
; LED_COUNT                 = 광학계에서 사용되는 LED 개수 (보통 4개. 265, 380, 395, 405. MAX:8개)
; PH_IPv4_xx                = 포토헤드 IPv4 주소 값 (01 ~ 08)
; PH_PITCH                  = 포토헤드 마다 세로 (상/하)로 그릴수 있는 Stripe 개수
;                             LLS50:2, LLS25:4/5, LLS10:8/10 (단, 광학계가 1개이면, 1 고정)
; USE_ANNOUNCEMENT          = 광학계로부터 Announce 정보를 받을지 여부 설정
;                             0 : 받지 않음, 1 : 받음 (기본 값 0 값. 1 값은 약간 불안정한 상태)
;                             참고로, 여기서 Announce 정보로는
;                             TestAnnounceMent : Test announcement number. Incrementing by 1 ...
;                             Error : Packet 필드 중 "Status"에 에러 값 수신부에 해당됨
;                             LoadState : Job (Gerber) Load 상태 값 정보
;                             ExposureState : 노광할 때, 노광 진행 상태 값
; USE_HW_INITED             = 프로그램 실행되고 광학계가 접속되면 자동으로 초기화할지 여부 결정
;                             광학계 쪽에 초기화 (HW Inited) 명령 송신 여부 설정
; PH_ROTATE                 = 포토헤드 방향 (0x00 = 회전 없음, 0x01 = 180도 회전)
; PARALLELOGRAM_ADJUST_x    = 모션 평행 (대각선) 이동 보정 (1000 => 1.0 (Default), 500 => 0.5)
; SCROLL_RATE               = 포토헤드가 처리할 수 있는 최대 이동 비율 값 (Default 19000)
;                             이 값을 변경하면 STEP 1 ~ 6 등 최대 노광 속도 값이 변경 됨
; TABLE_EXPO_START_X/Y_x    = 노광 시작 위치 값 (단위: mm) 실제 DMD로부터 빛이 나오는 시작 위치
;                             (모션이 이동하는 시작 위치는 아님) (소숫점 3자리까지 유효)
; MOTION_CONTROL_TYPE       = Motion Controller (MC3) Type 값 (Sieb & Meyer이므로, 1 고정)
; MOTION_CONTROL_IPv4       = Motion Controller (MC3) IP
; X_CORRECTION_TABLE_x      = 보정 테이블 (1 / 2)에 보정 값 입력 (0: 입력 없음, 1: 입력 함)
; Y_CORRECTION_TABLE_x      = 보정 테이블 (1 / 2)에 보정 값 입력 (0: 입력 없음, 1: 입력 함)
;                             별도 보정 값이 저장된 파일 참조 (읽고 & 분석)
; TABLE_LIMIT_MIN/MAX_X/Y_x = Work Table이 상/하, 좌/우 이동할 수 있는 최소/최대 값 (단위: mm)
;                             (소숫점 3자리까지 유효)
;                             만약, Table 개수가 2개이면, TABLE_POS_LIMIT_XXX_X_2 라고 하면 됨
; MAX_Y_MOTION_SPEED        = 테이블 Y 축 방향의 최대 이동 속도 (단위: mm/sec)
;                             (소숫점 3자리까지 유효)
; X_MOTION_SPEED            = 테이블 X 축 방향의 이동 속도 (단위: mm/sec) (소숫점 3자리까지 유효)
;                             최대 이동 속도가 아님. 보통, 노광 시작 위치로 이동하는 속도
; Y_ACCELERATION_DISTANCE   = Y 축 가속도가 정상 궤도에 오르기 위한 취소한의 여유 거리 (unit: mm)
;                             (소숫점 3자리까지 유효)
; HYS_TYPE_1_SCROLL_MODE    = 노광 동작 속도 모드 값 (높을 수록 스테이지 이동 속도 빠름) (1 ~ 6)
; HYS_TYPE_1_NEGATIVE_OFFSET= HysteresisType1 정보 설정
;                             HysteresisType1 Negative Offset (단위: Trigger Pulse)
;                             ex) 조건: moving (end - start): (394.198 - 20 mm), pulse count: 34450
;                                       1 offset size (pulse dist) = (end-start)
;                                       pulse_count = 10.8621 um
; ---------------------------------------------------------------------------------------------------
; !!! 아래 DELAY, OFFSET의 경우, 초기 Luria에 접속 후 최초 한번은 적용해 주며, 나머지는 사용 안됨 !!!
; ---------------------------------------------------------------------------------------------------
; HYS_TYPE_x_DELAY_xxxxTIVE = HysteresisType1 Moving Delay. Positive / Negative Delay (단위: mm)
;                             (소숫점 6자리까지 유효)
;                             Positive와 Negative를 1/2 씩 나누어서 배분해 줘야 됨
; PH_OFFSET_X               = 포토헤드 단차 (Offset) 설정 (Calibration Tool에 의해 값이 갱신 됨)
;                             포토헤드 1번 기준으로 2번부터 떨어진 간격 값 저장. X는 무조건 양수,
;                             Y는 정수 값 (단위: mm) (소숫점 6자리까지 유효)
;                              아래는 LLS25 기준으로, 초기에는 계산에 의한 값 입력
;                              Mirror Size     = 10.368
;                              PH_WIDTH        = (Mirror Count (W) * Mirror Size) * PH_PITCH
;                              PH_OFFSET_X_2   = PH_WIDTH * 1
;                              PH_OFFSET_X_3   = PH_WIDTH * 2
;                              PH_OFFSET_X_4   = PH_WIDTH * 3
;                              PH_OFFSET_X_5   = PH_WIDTH * 4
;                              PH_OFFSET_X_6   = PH_WIDTH * 5
;                              PH_OFFSET_X_7   = PH_WIDTH * 6
;                              PH_OFFSET_X_8   = PH_WIDTH * 7
;
; PH_OFFSET_Y               = 포토헤드 1번 기준으로, 2~8번 포토헤드가 상/하 발생된 오차 값 설정
;                             초기 값 0으로 설정 (Calibration Tool에 의해 값이 갱신 됨) (단위: mm)
;                             (소숫점 6자리까지 유효)
; ---------------------------------------------------------------------------------------------------
; TABLE_x_PRINT_DIRECTION   = 포토헤드가 노광하는 방향 (0 = Negative, 1 = Positive)
;                             (TABLE_COUNT 값 고려)
; ACTIVE_TABLE              = 초기 활성화 하려는 Table Number (Work Table 1 or 2)
;                             Double Gantry Type일 경우 고려. Single Stage일 경우, 무조건 1
;                             Double Gantry or Stage일 경우, 노광 할 때마다 Table Number가 바뀜
; EMULATE_xxxxxx            = 각종 하부의 장비와 연동되어 동작할지 여부 설정
;                             0 = 실제 장비 (모터, 포토헤드, 트리거)와 연동되어 [정상] 동작 함
;                             1 = 실제 장비 (모터, 포토헤드, 트리거)와 연동없이 [가상] 동작 함
; DEBUG_PRINT_LEVEL         = 서비스 동작 관련 로그 레벨 설정
;                             0 = Print Info. Only (노광 관련 로그만 출력)
;                             1 = Print Info. and Debug (노광 및 디버깅 로그만 출력)
;                             2 = Print Info., Debug and Trace Messages (모든 로그 출력)
;                             초기 세팅 과정에서는 2 값 입력, 정상 동작하면 1 값 입력 추천
; X/Y_DRIVE_ID_x            = 포토헤드에 모션 X / Y 축 SDS Drive ID 값 설정 (No : 0 ~ 7)
;                             보통 X = 0, Y = 1 (X or Y Drive ID 값이 동일하면 안됨)
; PRODUCT_ID                = 포토헤드 Product ID 값 설정
;                             (16702  = LLS2500, 25002  = LLS04, 50001  = LLS10, 100002 = LLS15)
;                             (100001 = LLS25,   235002 = LLS30, 200001 = LLS50)
; ARTWORK_COMPLEXITY        = Artwork Complexity
;                             (거버 복잡도에 따라 값 지정. 정확한 이해는 문서 참조)
;                             보통 0 값 지정
;                             (1 or 2 값의 경우, 포토헤드에 등록되는 거버 개수 제한 됨)
;                             0 = Normal, 1 = High, 2 = eXtreme
; Z_DRIVE_TYPE              = 광학계 Focus 움직이는 모터 종류
;                             1 = Stepper motor (built in)
;                             2 = Linear drive (ACS)
;                             3 = Linear drive (Sieb & Meyer)
;                                 (valid from version 2.10.0 and newer)
; Z_DRIVE_IPv4              = Z_DRIVE_TYPE == 3인 경우, MC2 IP Address
;                             MC2가 장비에 2대 이상 설치된 경우,
;                             MOTION_CONTROL_IPv4 이 주소와 다른 IPv4를 입력해야 함
; Z_DRIVE_SD2S_PH_1~8       = Linear Axis (SD2S)인 경우 즉, SD2S Drive 번호
;                             (보통 X Axis:0, Y Axis:1, ACam1 Axis :2, ACam2 Axis:3, PH1:4 ~...)
; OVER_PRESSURE_MODE        = 포토헤드 내부에 과부하가 발생한 경우 냉각 팬 동작 유무 설정
;                             1 = Over pressure mode ON, 0 = Over pressure mode OFF
; 아래 2개의 변수의 경우, 구미 SKC 장비의 경우 의미 없음
; PH_Z_AXIS_MOVE_MAX        = 포토헤드 Z 축을 최대한 다운 (DOWN) 할 수 있는 최대치 값 (단위: mm) ;
; PH_Z_AXIS_MOVE_MIN        = 포토헤드 Z 축을 최대한 업 (UP) 할 수 있는 최소치 값 (단위: mm)
;                             (소숫점 4자리까지 유효)
; PH_Z_AXIS_FOCUS_x         = 각 Photohead 별로 설정된 Z Axis 노광 높이 값 (단위: mm)
;                             [SETUP_ALIGN] DOF_FILM_THICK 기준으로 Z Axis (FOCUS) 높이 값
;                             (단위: mm) (소수점 4자리까지 유효)
; DMD_MIRROR_COUNT_X        = DMD Mirror Counts : X
; DMD_MIRROR_COUNT_Y        = DMD Mirror Counts : Y
; MAX_PRINT_SPEED           = Scroll Mode 1일 때, 노광 최대 속도 (mm/sec) (소숫점 3자리까지 유효)
; SENSOR_DIAMETER           = 조도 센서 직경 길이 (Circle임. 단위: mm) (소숫점 3자리까지 유효)
; CORRECTION_FACTOR         = 조도 Power 계산하기 위한 개수 값 (소숫점 3자리까지 유효)
; ILLUM_FILT_RATE_LED_x     = LED 0 ~ 3 번까지 조도 측정을 위한 센서 필터 전후 값 비율
;                             (초기 LED Power 설정할 때, 얻어지는 값)
;                             측정된 값에 100.0f 값을 곱한 값 (Percentage)
; ILLUM_GARBAGE_PWR         = DMD가 ON되지 않은 상태에서, 조도 센서로부터 수집되는 최대 값 설정
;                             즉, 이 값 이상으로 측정되면, 더 이상 측정 작업을 할 수 없음 (단위: mW)
;                             조도 센서의 최소 측정 단위 값이 1 nm 이므로, 0.001 mW 이하이면 OK
; ILLUM_MEAS_TYPE           = 조도 측정 대상 (1:Power, 2:Energy, 3:Frequency, 4:Density)
; PIXEL_SIZE                = Lens 배율과 Scroll Mode (Scroll Step Size)에 따라 다름 (단위:um)
;                               (소숫점 6자리까지 유효)
;                             Pixel Resolution (5.4 or 10.8 or 21.6 um)
;                                              (unit: pm; picometer = 1/1000 nm)
;                             유효한 값은 nanometer 단위 (아래 값은 picometer 단위까지 표현됨)
;                           	<LLS 10> <lens:  500>
;                                    Scroll mode 1	:  5.4310344828	um
;                                    Scroll mode 2	: 10.8620689655	um
;                                    Scroll mode 3	: 16.2931034483	um
;                                    Scroll mode 4	: 21.724137931	um
;                           	<LLS 25> <lens: 1000>
;                                    Scroll mode 1	: 10.8620689655	um
;                                    Scroll mode 2	: 21.724137931	um
;                                    Scroll mode 3	: 32.5862068966	um
;                                    Scroll mode 4	: 43.4482758621	um
; 아래 2개의 변수의 경우, 구미 SKC 장비의 경우 의미 없음
; AF_GAIN                   = AutoFocus Gain (1 ~ 4095) : 신호 증가 / 감소 : 인식률 높이기 위함?
; AF_RANGE_MIN/MAX_ALL      = AutoFocus Work Range Min/Max (단위: mm)
;-------------------------------------------------------------------------------------------------

[PH_SERVICE]

OPTIC_VER_MAJOR             = 2
OPTIC_VER_MINOR             = 4
OPTIC_VER_BUILD             = 5106

TABLE_COUNT                 = 1
TOTAL_PH                    = 2
LED_COUNT                   = 4
USE_ANNOUNCEMENT            = 1
USE_HW_INITED               = 1

PH_IPv4_01                  = 192.168.0.10
PH_IPv4_02                  = 192.168.1.10
PH_IPv4_03                  = 192.168.2.10
PH_IPv4_04                  = 192.168.3.10
PH_IPv4_05                  = 192.168.4.10
PH_IPv4_06                  = 192.168.5.10
PH_IPv4_07                  = 192.168.6.10
PH_IPv4_08                  = 192.168.7.10


; 2022-03-07 (PODIS for SKC)
HYS_TYPE_1_SCROLL_MODE      = 1
HYS_TYPE_1_NEGATIVE_OFFSET  = 2
HYS_TYPE_1_DELAY_POSITIVE   = 0.000000
HYS_TYPE_1_DELAY_NEGATIVE   = 0.000000

; 2022-11-08
PH_OFFSET_X_2               = 206.213300
PH_OFFSET_Y_2               = -0.023600
; 2022-07-20
PH_OFFSET_X_2               = 206.039100
PH_OFFSET_Y_2               = 0.073300
; 2022-03-11
;PH_OFFSET_X_2               = 206.030100
;PH_OFFSET_Y_2               = 0.074000
; 2022-03-06
;PH_OFFSET_X_2               = 205.796100
;PH_OFFSET_Y_2               = 0.070700

; 노광 시작 위치 (기본:X10, Y56)
TABLE_EXPO_START_X_1        = 10.000
TABLE_EXPO_START_Y_1        = 56.000
PH_PITCH                    = 20
PH_ROTATE                   = 1
TABLE_LIMIT_MIN_X_1         = 0.010
TABLE_LIMIT_MIN_Y_1         = 0.020
TABLE_LIMIT_MAX_X_1         = 600.000
TABLE_LIMIT_MAX_Y_1         = 1600.000
MAX_Y_MOTION_SPEED          = 300.000
X_MOTION_SPEED              = 200.000
Y_ACCELERATION_DISTANCE     = 2.000
PRODUCT_ID                  = 50001
PH_Z_AXIS_MOVE_MAX          = 84.000
PH_Z_AXIS_MOVE_MIN          = 64.000
; 2022-11-08 (LLS10) (PH1번 누수로 교체 글라스 720um)
PH_Z_AXIS_FOCUS_1           = 68.3400
PH_Z_AXIS_FOCUS_2           = 69.5000
; 2022-03-14 (LLS10) (200um : CCL 필름 기준 : 노광 후 측정)
;PH_Z_AXIS_FOCUS_1           = 69.2300
;2022-07-20 foxcus test 후 조정(기존 대비 40 + 10)
;PH_Z_AXIS_FOCUS_2           = 69.4700
;PH_Z_AXIS_FOCUS_2           = 69.4600
DMD_MIRROR_COUNT_X          = 1920
DMD_MIRROR_COUNT_Y          = 1080
PIXEL_SIZE                  = 5.431034
Z_DRIVE_TYPE                = 1
Z_DRIVE_IPv4                = 0.0.0.0

;2022-02-09
PARALLELOGRAM_ADJUST_1      = 1000
PARALLELOGRAM_ADJUST_2      = 1000
SCROLL_RATE                 = 17000
MOTION_CONTROL_TYPE         = 1
MOTION_CONTROL_IPv4         = 100.100.100.11
X_CORRECTION_TABLE_1        = 0
Y_CORRECTION_TABLE_1        = 0
TABLE_1_PRINT_DIRECTION     = 1
TABLE_2_PRINT_DIRECTION     = 0
ACTIVE_TABLE                = 1
EMULATE_MOTION              = 0
EMULATE_PH                  = 0
EMULATE_TRIGGER             = 0
DEBUG_PRINT_LEVEL           = 2
X_DRIVE_ID_1                = 0
Y_DRIVE_ID_1                = 1
ARTWORK_COMPLEXITY          = 0
Z_DRIVE_SD2S_PH_1           = 4
Z_DRIVE_SD2S_PH_2           = 5
OVER_PRESSURE_MODE          = 0

; 조도 센서 측정 크기
SENSOR_DIAMETER             = 9.500
CORRECTION_FACTOR           = 1.000

; LED1 vs. LED2 vs. LED3 vs. LED4 = 3.2W vs. 3.1W vs. 2.4W vs. 3.2W
ILLUM_FILT_RATE_LED_0       = 33.45000
ILLUM_FILT_RATE_LED_1       = 31.34766
ILLUM_FILT_RATE_LED_2       = 39.39151
ILLUM_FILT_RATE_LED_3       = 35.84000
ILLUM_GARBAGE_PWR           = 0.0010
ILLUM_MEAS_TYPE             = 1

; AutoFocus
AF_GAIN                     = 10
AF_RANGE_MIN_ALL            = 0.500
AF_RANGE_MAX_ALL            = 24.000

;-------------------------------------------------------------------------------------------------
; [MC2_SERVICE]
;
; MC2_SERIAL            = Serial number of MC2 device (password: g3ul2xx) -> xx:
;                         The current minute of local system
;                         Q-CELLS           : 1000390436
;                         PODIS             : 1000357259
;                         GEN2i (1 호기)    : 1000451419
;                         GEN2i (2 호기)    : 1000451418
;
; PH_VER                = 0x01 : V1, 0x02 : V2 (Luria Area Mode 설정할 때 중요함)
;
; DRIVE_COUNT           = Motion Drive 개수 (최대 8개)
; ORIGIN_POINT          = Motion이 이동할 때, X / Y 시작 (0.0000 mm, 0.0000 mm) 위치 기준 값
;                         0:Left/Bottom, 1:Left/Top, 2:Right/Bottom, 3:Right/Top
;
; MOVE_VELO             = 일반적인 수동 (시나리오) 조작할 때, 이동 속도 (단위: mm/sec)
; MARK_VELO             = Align Mark 검사할 때, Y 축 이동 속도 값 (단위: mm/sec)
; STEP_VELO             = 광학계 및 기타 단차 측정할 때, 얼라인 카메라 이동 속도
; MOVE_DIST             = 일반적인 수동 조작할 때, 이동 거리 (단위: mm)
;
; AXIS_ID_xx            = Axis (Motor) moving speed value (unit: mm / sec)
;                         -. Value must be set for all 8 axes, max. 600mm or less
;                         -. If Gantry Type is set, the velocity values of 01 & 02 Axis
;                            must be set to the same value.
;                         -. x : SD2S Driver (motor axis) ID
;
;                                ex> The demo DI for SKC
;                                drv 0 : Stage X (Max 250 mm/sec)
;                                    1 : Stage Y (Max 500 mm/sec)
;                                    2 : Reserved
;                                    3 : Reserved
;                                    4 : Camera 1
;                                    5 : Camera 2
;                                    6 : Reserved
;                                    7 : Reserved
;
;                                ex> The commercial DI for SKC
;                                drv 0 : Stage X (Max 250 mm/sec)
;                                    1 : Stage Y (Max 500 mm/sec)
;                                    2 : Camera 1
;                                    3 : Camera 2
;                                    4 : PH 1 Z Axis
;                                    5 : PH 2 Z Axis
;                                    6 : reserved_1
;                                    7 : reserved_2
;
;                            ------------------------------------------
;                         -. !!! Align Mark 검색할 때, 이 속도 적용 !!!
;                            ------------------------------------------
;
; MIN_AXIS_xx_DIST      = xx Minimum travel distance based on Axis (unit: mm)
;                         -. There are no values to be set for all eight axes.
;                         -. The remaining values are 0, but in the case of an aligned camera,
;                            there is a negative value.
;
; MAX_AXIS_xx_DIST      = Xx Maximum travel distance in terms of Axis (unit: mm)
;                         -. All eight values must be set.
;                         ex> (0) Stage X  :  325.0500 or 325.0400
;                             (1) Stage Y  : 1208.0000 or 496.8000
;                             (2) Gantry Y : 1208.0000 or 496.8000
;                             (3) Loader   : 1208.0000 or 195.8840
;                             (4) Camera1  : 1208.0000 or 195.8840
;-------------------------------------------------------------------------------------------------

[MC2_SERVICE]

; 2022-03-18 (PODIS for SKC)
MC2_SERIAL              = 1000357259
;MC2_SERIAL               = 1000390434
DRIVE_COUNT             = 4
AXIS_ID_1               = 0
AXIS_ID_2               = 1
AXIS_ID_3               = 4
AXIS_ID_4               = 5
MIN_AXIS_0_DIST         = 0.0000
MIN_AXIS_1_DIST         = 0.0000
MIN_AXIS_4_DIST         = 0.0000
MIN_AXIS_5_DIST         = 0.0000
MAX_AXIS_0_DIST         = 315.0000
MAX_AXIS_1_DIST         = 1650.0000
MAX_AXIS_4_DIST         = 959.0000
MAX_AXIS_5_DIST         = 959.0000
MAX_AXIS_0_VELO         = 400.0000
MAX_AXIS_1_VELO         = 400.0000
MAX_AXIS_4_VELO         = 200.0000
MAX_AXIS_5_VELO         = 200.0000

; 2022-03-21
MOVE_VELO               = 200.0000
MARK_VELO               = 200.0000
STEP_VELO               = 100.0000
MOVE_DIST               = 1.0000

PH_VER                  = 1
ORIGIN_POINT            = 0

;-------------------------------------------------------------------------------------------------
; [MELSEC_Q_SERVICE]
;
; Network module information installed in the PLC
; (the characters listed below are hexadecimal string values)
;
;   . Starting I/O No   = 0110  'Head I / O (fixed value of 0x03ff if it is not MULTI-DROP)
;   . Network No        = 0     'Network (fixed value of 0 if not MULTI-DROP)
;   . Group No          = 0     'Group (I do not know, 0 value unconditionally)
;   . Station No        = 0     'Station number (fixed value of 0 when it is not MULTI_DROP)
;   ' PLC_NO            = ff    'PLC number (fixed value of 0xff when it is not MULTI_DROP)
;
; MC packet configuration information
;
; Header portion
;   "5000"  (35 30 30 30)       'Sub header
;   "00"    (30 30)             'Network number
;   "FF"    (46 46)             'PC number (PLC number for serial communication)
;   "03E0"  (30 33 45 30)       'Request module I / O number (or Starting I / O No)
;   "00"    (30 30)             'Requested station number (Station No)
;   "0018"  (30 30 31 38)       'Request data length
;   "0010"  (30 30 31 30)       'CPU watchdog timer
;   "0401"  (30 34 30 31)       'Command (0401 - Read)
;   "0001"  (30 30 30 31)       'Subcommand (Combination with command)
;                               '   0401 0001 -> Batch reading in bit units
;                               '   0401 0000 -> Batch reading in word units
;                               '   1401 0001 -> Bitwise batch writing
;                               '   1401 0000 -> Bulk writing in word units
;   "M*"    (40 2A)             'Device code
'                               ' Code type : X, Y, M, L, B, T, C, ST, D, W, R, ZR
;   "000100"(30 30 30 31 30 30) ' Head device (address)
;   "0008"  (30 30 30 38)       ' Device points count
;
; MELSEC address size (8 BITS, that is, 1 BYTE unit) (not created if the number of memory is 0)
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; !!! Important !!! -> 될 수 있으면 아래 항목들은 8의 배수 값이 되도록 설정해 주길 바람
;                      (참고로, X, Y, M 주소 값은 현재 지원 안됨. 무조건 0 값)
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ADDR_X_COUNT      = X area memory count ( 1 bits area / WORD counts)
;                                         (ex> If the score is 64,      8 BYTES)
; ADDR_Y_COUNT      = Y area memory count ( 1 bits area / WORD counts)
;                                         (ex> If the score is 128,     16 BYTES)
; ADDR_M_COUNT      = M area memory count ( 1 bits area / WORD counts)
;                                         (ex> If the score is 5100,    638 BYTES)
; ADDR_D_COUNT      = D area memory count (16 bits area / WORD counts)
;                                         (ex> If the score is 2200,    4400 BYTES)
; ADDR_D_START      = PLC 시작 주소 (WORD 단위 기반의 D 레지스트의 시작 주소)
;-------------------------------------------------------------------------------------------------

[MELSEC_Q_SERVICE]

START_IO            = 03ff
GROUP_NO            = 0
NETWORK_NO          = 0
STATION_NO          = 0
PLC_NO              = ff

ADDR_X_COUNT        = 0
ADDR_Y_COUNT        = 0
ADDR_M_COUNT        = 0
ADDR_D_COUNT        = 128
ADDR_D_START        = 1100

;----------------------------------------------------------------------------------------------------
; [PODIS_COMN]          = PODIS 전용 공통
;
; CHECK_HOT_AIR         = 0:온조기 동작 확인하지 않음. 1:온조기 동작여부 확인
; CHECK_CHILLER         = 0:칠러 동작 확인하지 않음. 1:칠러 동작여부 확인
; CHECK_VACUUM          = 0:베큠 동작 확인하지 않음. 1:베큠 동작여부 확인
; CHECK_MATERIAL        = 0:노광 소재 존재 확인하지 않음. 1:노광 소재 존재여부 확인
; CHECK_START_LED       = 0:장비 전면 Start LED 버튼 확인하지 않음 1:동작 확인함
; CHECK_QUERY_EXPO      = 최종 얼라인 진행 후 노광 진행 여부 물어보기 설정 여부
;                         0:물어보는 것 없이 진행, 1:한번더 노광을 진행할 것인지 물어보기
; USE_VISION_LIBRARY    = 0 : Vision Library 사용 안함, 1 : Vision Library 사용 함
; LOAD_RECIPE_HOMING    = 레시피 적재할 때, 광학계 Homing 할지 여부 (0 : Not homing, 1 : Homing)
;
;----------------------------------------------------------------------------------------------------

[PODIS_COMN]

CHECK_HOT_AIR           = 1
CHECK_CHILLER           = 1
CHECK_VACUUM            = 1
CHECK_MATERIAL          = 1
CHECK_START_LED         = 0
CHECK_QUERY_EXPO        = 1
USE_VISION_LIBRARY      = 1
LOAD_RECIPE_HOMING      = 0

;----------------------------------------------------------------------------------------------------
; [FILE_NAME]           = 참고로 기본 확장자는 dat 즉, xxx.dat
;
; FILE_LED_POWER        = Led Power 데이터가 저장된 파일 (확장자 포함)
; FILE_GERB_RECIPE      = Recipe 기본 파일
; FILE_MARK_RECIPE      = 등록된 Mark Recipe 파일
; FILE_MARK_MODEL       = 등록된 Mark Model 파일
; FILE_PH_STEP          = 광학계 단차 정보 파일
; FILE_ACAM_CALI        = 얼라인 카메라의 2D 보정 정보 파일
; FILE_TRIG_CALI        = 트리거 보정 정보 파일
; FILE_CORRECT_Y        = 광학 정역 단차에 대한 보정 수치 파일
;----------------------------------------------------------------------------------------------------

[FILE_NAME]

FILE_LED_POWER          = led_power
FILE_GERB_RECIPE        = gerb_recipe
FILE_JOB_RECIPE         = job_recipe
FILE_EXPO_RECIPE        = expo_recipe
FILE_ALIGN_RECIPE       = align_recipe
FILE_MARK_RECIPE        = mark_recipe
FILE_MARK_MODEL         = mark_model
FILE_MARK_ROI	= mark_roi
FILE_PH_STEP            = ph_step
FILE_ACAM_CALI          = acam_cali
FILE_TRIG_CALI          = trig_cali
FILE_THICK_CALI         = thick_cali
FILE_CORRECT_Y          = correct_y

[RECIPE]
CURRENT_RECIPE		= job1
;-------------------------------------------------------------------------------------------------
; [SETUP_CAMERA]
;
; ACAM_COUNT            = 설치된 Align Camera 개수
;
; ACAM_INST_ANGLE       = 카메라가 설치될 때, 회전 여부 (0: 회전 없음, 1: 180도 회전)
;
; ACAM_WIDTH            = 사양 기준으로 카메라 해상도 (최대) - 넓이 (단위: pixel)
; ACAM_HEIGHT           = 사양 기준으로 카메라 해상도 (최대) - 높이 (단위: pixel)
;                         ex> Baser Camera  : 1920 x 1200 (basler (ace U) acA1920-50gm)
;                                             => pixel size = 5.86 / Resolution = 2.3 MP
;                             IDS Camera    : 1920 x 1080
;
; MOVE_UP/DN_LIMIT      = 얼라인 카메라가 설치된 Z 축 Up/Down Limit 값. 표현 값 범위는 100 nm까지
;                         (단위: mm) (소수점 4자리까지 유효)
;
; 참고로, XXX_WIDTH 값은 (!!! 항상 8의 배수 값 !!!)
; AOI_WIDTH             = Align Mark Search를 위한 FOV 관심 영역
; AOI_HEIGHT            = Align Mark Search를 위한 FOV 관심 영역
; SOI_WIDTH             = Vision Step Search를 위한 FOV 관심 영역
; SOI_HEIGHT            = Vision Step Search를 위한 FOV 관심 영역
; DOI_WIDTH             = Align Camera DOF Focusing을 위한 FOV 관심 영역
; DOI_HEIGHT            = Align Camera DOF Focusing을 위한 FOV 관심 영역
; MES_WIDTH             = Vision Calibration Measurement을 위한 FOV 관심 영역
; MES_HEIGHT            = Vision Calibration Measurement을 위한 FOV 관심 영역
; IOI_WIDTH             = Vision Shutting Inspection을 위한 FOV 관심 영역
; IOI_HEIGHT            = Vision Shutting Inspection을 위한 FOV 관심 영역
; SPC_WIDTH             = Align Camera Specification을 위한 FOV 관심 영역
; SPC_HEIGHT            = Align Camera Specification을 위한 FOV 관심 영역
; STG_WIDTH             = Stage XY Straightness를 위한 FOV 관심 영역
; STG_HEIGHT            = Stage XY Straightness를 위한 FOV 관심 영역
; HOL_WIDTH             = Material Hole Size를 위한 FOV 관심 영역
; HOL_HEIGHT            = Material Hole Size를 위한 FOV 관심 영역
;-------------------------------------------------------------------------------------------------

[SETUP_CAMERA]

ACAM_COUNT              = 2
ACAM_INST_ANGLE         = 1

ACAM_WIDTH              = 1920
ACAM_HEIGHT             = 1200

MOVE_UP_LIMIT           = 15.0000
MOVE_DN_LIMIT           = -15.0000

AOI_WIDTH               = 1920
AOI_HEIGHT              = 1200
;SOI_WIDTH               = 1600
;SOI_HEIGHT              = 1200
SOI_WIDTH               = 1200
SOI_HEIGHT              = 600
DOI_WIDTH               = 800
DOI_HEIGHT              = 800
MES_WIDTH               = 800
MES_HEIGHT              = 800
IOI_WIDTH               = 1200
IOI_HEIGHT              = 1200
SPC_WIDTH               = 1200
SPC_HEIGHT              = 1200
STG_WIDTH               = 800
STG_HEIGHT              = 800
HOL_WIDTH               = 800
HOL_HEIGHT              = 800

;-------------------------------------------------------------------------------------------------
; [CAMERA_BASLER]
;
; CAM_GAIN_LEVEL    = Align Camera Gain Level 값 (0 ~ 255) (CAMERA 1 / 2
;
; CAM_REVERSE_X     = 카메라 Grabbed Image 영상 반전 (좌/우)
; CAM_REVERSE_Y     = 카메라 Grabbed Image 영상 반전 (상/하)
;
; CAM_IPv4_x        = 카메라 IPv4
;
; FRAME_xx          = Sets the number of frames acquired in the multiframe acquisition mode
; TIME_xx           = GRAP_xx : PODIS App에서 사용될 카메라의 Expose Time (um sec)
;                     STEP_xx : VDOF App에서 사용될 카메라의 Expose Time (um sec)
;                     최소 입력할 수 있는 값 : 24
; CAM_MC2_DRV_x     = MC2 SD2S 기준 드라이브의 번호 (보통 0,1 번은 스테이지 X/Y)
; Z_AXIS_MOVE_MIN   = Z Axis 최소 값 (단위: mm) (IDS : 65 mm, Basler : -15 mm)
; Z_AXIS_MOVE_MAX   = Z Axis 최대 값 (단위: mm) (IDS : 80 mm, Basler : +15 mm)
;                     ex> -15.0000 -> -15 mm / 15.0000 -> 15 mm
; Z_AXIS_BASE_POS_x =외부에 설치된 Camera Z Axis 높이 값 (단위: mm)
;                     [SETUP_ALIGN]-DOF_FILM_THICK 기준으로 Z Axis (FOCUS) 높이 값임
;-------------------------------------------------------------------------------------------------

[CAMERA_BASLER]

CAM_1_GAIN_LEVEL    = 235
CAM_2_GAIN_LEVEL    = 255

;film - CAM1 180, CAM2 120

; 2021-09-16
;CAM_1_GAIN_LEVEL    = 0
;CAM_2_GAIN_LEVEL    = 0

CAM_REVERSE_X       = 0
CAM_REVERSE_Y       = 0

CAM_IPv4_1          = 192.168.11.51
CAM_IPv4_2          = 192.168.12.51

CAM_MC2_DRV_1       = 4
CAM_MC2_DRV_2       = 5

FRAME_1             = 1
TIME_GRAB_1         = 24
TIME_STEP_1         = 50

FRAME_2             = 1
TIME_GRAB_2         = 24
TIME_STEP_2         = 50

Z_AXIS_MOVE_MIN     = -15.0000
Z_AXIS_MOVE_MAX     = 15.0000

;-------------------------------------------------------------------------------------------------
; [TRIG_GRAB]
;
; CH_COUNT              = 제품에 적용되는 트리거의 개수 (보통 짝수개 이어야 함)
;
; TRIG_ON_TIME_x        = high가 유지되는 값을 입력 (ns)
; STROBE_ON_TIME_x      = high가 유지되는 값을 입력 (ns)
; TRIG_DELAY_TIME_x     = 출력되는 Trigger의 Delay 값 입력 (ns)
;                         이 Register 값이 0   이면, Strobe와 Trigger 신호는 동시에 출력 됨
;                         이 Reigster 값이 1000 이면, Strobe에 신호가 출력되고,
;                         1000ns 초 만큼 대기 (지연) 후에 Trigger에 신호가 출력 됨
; TRIG_FORWARD          = 정방향 이동할 때, Area Trigger (1 ~ 16) 값에 이 Register 값이
;                         <증가/감소>되어, Strobe와 Trigger의 신호가 빠르게/느리게 출력 됨 (양수/음수)
; TRIG_BACKWARD         = 역방향 이동할 때, Area Trigger (1 ~ 16) 값에 이 Register 값이
;                         <증가/감소>되어,Strobe와 Trigger의 신호가 빠르게/느리게 출력 됨 (양수/음수)
;-------------------------------------------------------------------------------------------------

[TRIG_GRAB]

CH_COUNT                = 4

; Align Mark 인식용 (On The Fly)
TRIG_ON_TIME_1          = 600
TRIG_ON_TIME_2          = 600
TRIG_ON_TIME_3          = 600
TRIG_ON_TIME_4          = 600

STROBE_ON_TIME_1        = 40000
STROBE_ON_TIME_2        = 40000
STROBE_ON_TIME_3        = 40000
STROBE_ON_TIME_4        = 40000

TRIG_DELAY_TIME_1       = 300
TRIG_DELAY_TIME_2       = 300
TRIG_DELAY_TIME_3       = 300
TRIG_DELAY_TIME_4       = 300

; 2022-05-16 (감광 필름. 960 um) (외부:Temp 21.1, 내부(4):22.2)
TRIG_FORWARD            = -85
TRIG_BACKWARD           = 100

; 2022-04-29 (감광 필름. 960 um) (외부:Temp 22.9, 내부(4):??.?)
;TRIG_FORWARD            = -160
;TRIG_BACKWARD           = 100

; 2022-04-28 (감광 필름. 960 um) (외부:Temp 25.2)
;TRIG_FORWARD            = -185
;TRIG_BACKWARD           = 100

;-------------------------------------------------------------------------------------------------
; [TRIG_STEP]
;
; CH_COUNT              = 제품에 적용되는 트리거의 개수 (보통 짝수개 이어야 함)
;
; TRIG_ON_TIME_x        = high가 유지되는 값을 입력 (ns)
; STROBE_ON_TIME_x      = high가 유지되는 값을 입력 (ns)
; TRIG_DELAY_TIME_x     = 출력되는 Trigger의 Delay 값 입력 (ns)
;                         이 Register 값이 0   이면, Strobe와 Trigger 신호는 동시에 출력 됨
;                         이 Reigster 값이 1000 이면, Strobe에 신호가 출력되고,
;                         1000ns 초 만큼 대기 (지연) 후에 Trigger에 신호가 출력 됨
; TRIG_FORWARD          = 정방향 이동할 때, Area Trigger (1 ~ 16) 값에 이 Register 값이
;                         <증가/감소>되어, Strobe와 Trigger의 신호가 빠르게/느리게 출력 됨 (양수/음수)
; TRIG_BACKWARD         = 역방향 이동할 때, Area Trigger (1 ~ 16) 값에 이 Register 값이
;                         <증가/감소>되어,Strobe와 Trigger의 신호가 빠르게/느리게 출력 됨 (양수/음수)
;-------------------------------------------------------------------------------------------------

[TRIG_STEP]

CH_COUNT                = 2

TRIG_ON_TIME_1          = 1000
TRIG_ON_TIME_2          = 1000

STROBE_ON_TIME_1        = 3000
STROBE_ON_TIME_2        = 3000

TRIG_DELAY_TIME_1       = 1000
TRIG_DELAY_TIME_2       = 1000

TRIG_FORWARD            = 0
TRIG_BACKWARD           = 0

;-------------------------------------------------------------------------------------------------
; [SETUP_ALIGN]
;
; USE_2D_CALI_DATA          = Align Camera의 2D Calibration Data 적용 여부 (1:사용, 0:미사용)
; USE_INVALID_MARK_CALI     = 인식되지 않은 Mark에 대해 강제(수동)로 인식시킬지 여부 (1:사용, 0:미사용)
;
; DOF_FILM_THICK            = Align Camera & Photohead Focus 조정할 때 사용되는소재의 두께 (단위: mm)
;
; ALIGN_METHOD              = 0 : Align Camera 2개로 Mark 2 or 4개 측정 (이동하면서 측정)
;                             1 : Align Camera 2개로 Mark 2 측정 후 중간에 멈추고, 카메라 좌/우 조정 후 다시 나머지 2개 측정 (이동 후 멈추고 측정, 다시 이동 후 측정)
;                                 거버 내 마크의 4 점이 직사각형 (카메라 FOV에 들어오지 못하는 경우)이 아닌 경우
;                             2 : Align Camera 1개로 임의 마크 측정 (멈추면서 측정)
;
; TABLE_UNLOADER_X/Y_x      = 노광 소재를 올려 놓기 위한 스테이지의 작업 위치
;                             (단위: mm) (소수점 4자리까지 유효)
; 아래 3개의 변수의 경우, 실제 MARK2 정보가 아니라, 노광되는 맨 왼쪽 최 하단의 노광되는 좌표 값임
; MARK2_ORG_GERB_X          = 거버에 저정된 Mark 2 (맨 왼쪽 최 하단)번의 X 좌표 (단위: mm) (소수점 4자리까지 유효)
; MARK2_ORG_GERB_Y          = 거버에 저정된 Mark 2 (맨 왼쪽 최 하단)번의 Y 좌표 (단위: mm) (소수점 4자리까지 유효)
; MARK2_STAGE_X             = 거버에 저장된 Mark 2 (맨 왼쪽 최 하단)번 기준 X 축 모션 좌표 (단위: mm)
;
;-------------------------------------------------------------------------------------------------

[SETUP_ALIGN]

USE_2D_CALI_DATA            = 1
USE_INVALID_MARK_CALI       = 1

; 2021-08-31 (LLS10) (CCL  + FILM :  200 um)
DOF_FILM_THICK              = 0.2000
; 2021-08-24 (LLS10) (CCL  + FILM :  170 um)
;DOF_FILM_THICK              = +0.1700
; 2021-08-16 (LLS10) (CCL  + FILM :  120 um)
;DOF_FILM_THICK              = +0.1200
;DOF_FILM_THICK             = +0.1800

ALIGN_METHOD                = 0

TABLE_UNLOADER_X_1          = 280.0000
TABLE_UNLOADER_Y_1          = 1650.0000


; 2022-10-17 수정
MARK2_ORG_GERB_X            = 6.1757
MARK2_ORG_GERB_Y            = 5.4050
MARK2_STAGE_X               = 160.0000

; 2022-09-28 수정
;MARK2_ORG_GERB_X            = 6.1747
;MARK2_ORG_GERB_Y            = 5.3995
;MARK2_STAGE_X               = 160.0000

; 2022-09-27 수정
;MARK2_ORG_GERB_X            = 6.1747
;MARK2_ORG_GERB_Y            = 5.3965
;MARK2_STAGE_X               = 160.0000

; 2022-07-01 임시 수정
;MARK2_ORG_GERB_X            = 6.1711
;MARK2_ORG_GERB_Y            = 5.4024
;MARK2_STAGE_X               = 160.0000

; 2022-03-16 (CALI_2D_5x5_510x515_DOT_G11)
;MARK2_ORG_GERB_X            = 5.6109
;MARK2_ORG_GERB_Y            = 5.1287
;MARK2_STAGE_X               = 160.0000

; 2022-03-14 (PH_STEP_510x25_D12_1MM_205978100)
;MARK2_ORG_GERB_X            = 11.1104
;MARK2_ORG_GERB_Y            = 8.12827586202
;MARK2_STAGE_X               = 160.0000

;-------------------------------------------------------------------------------------------------
; [GRAB_PRE_PROC]
;
; Grabbed Image 전처리를 위한 매개 변수 값
;
; 아래 2개 변수 중 1개 값이 0인 경우, 이 기능을 사용하지 않음
; USE_GRAB_PRE_PROC     = 0 : 사용 안함, 1 : 사용함
; USE_NOISE_REMOVE      = 0 : 노이즈 제거 안함, 1 : 노이즈 제거 기능 사용함
; USE_THIN_OPERATION    = 이미지 가장 자리를 얇게 처리할지 여부
;                         !!! 현재로선 이 플래그 값은 0 값으로 무조건 설정 !!!
; USE_SMALL_PARTICLE    = 작은 이미지 조각들 제거 기능 사용 여부 (0 or 1)
; MIM_BIN_CONDITION     = 3 (M_EQUAL), 4 (M_NOT_EQUAL), 5 (M_GREATER), 6 (M_LESS),
;                         7 (M_GREATER_OR_EQUAL), 8 (M_LESS_OR_EQUAL)
;                         3, 4 값은 될 수 있으면 사용하지 말자,
;                         주로 7,8 중 하나를 선택해서 사용하길
;                         7 : 정상적으로 출력, 8 : 흑백 반전 시켜서 출력
; REMOVE_SMALL_PARTICLE = Remove Small Particles (unit : pixel) 이 값이 크면, 작은 객체들은 없어짐
; REMOVE_SMALL_PROCMODE = M_BINARY (4096) or M_GRAYSCALE (512)
; THIN_PROC_MODE        = M_BINARY (4096), M_BINARY2 (1), M_BINARY3 (2) or M_GRAYSCALE (512)
;-------------------------------------------------------------------------------------------------

[GRAB_PRE_PROC]

USE_GRAB_PRE_PROC       = 0
USE_NOISE_REMOVE        = 1
USE_THIN_OPERATION      = 0
USE_SMALL_PARTICLE      = 1

MIM_BIN_CONDITION       = 7
REMOVE_SMALL_PARTICLE   = 5
REMOVE_SMALL_PROCMODE   = 512
THIN_PROC_MODE          = 512

;-------------------------------------------------------------------------------------------------
; [CALI_FIND]           -> Not used
;
; MODEL_TYPE            = M_CIRCLE (8), M_ELLIPSE (16), M_SQUARE (32), M_RECTANGLE (64)
;                         (나머진 제외)
; MODEL_COLOR           = BLACK (256), WHITE (128)
; MODEL_CALI            = Calibration Object
;                         (MODEL SIZE (unit : um) - Width or Diameter or Radius or Etc)
;-------------------------------------------------------------------------------------------------

[CALI_FIND]

MODEL_TYPE              = 8
MODEL_COLOR             = 256.000000
MODEL_CALI              = 500.000000

;-------------------------------------------------------------------------------------------------
; [MARK_FIND]
;
; MAX_MARK_REGIST       = 최대 등록 가능한 마크 모델 개수 (255개 넘으로면 안됨)
; MAX_MARK_GRAB         = 마크 검색을 위해 Grabbed Image의 최대 개수 (Max : 255) (Normal : 4)
;                         !!! 주의 !!! : 카메라 별로 검색할 수 있는 최대 개수
;                         즉, 카메라 마다 이미지를 Grab할 수 있는 최대 개수
;                         ex> 등록된 마크의 개수가 4개이고, 카메라가 1대이면, 4
;                             등록된 마크의 개수가 4개이고, 카메라가 2대이면, 2
; MAX_MARK_FIND         = Grabbed Image에서 검색 가능한 마크 최대 개수 (최대 255개 넘으면 안됨)
; SCORE_RATE            = 마크 인식 후 매칭률이 현재 설정 값보 떨어지면, UI에서 색상으로 표현
;                         이 값보다 매칭률이 떨어지면 더 이상 얼라인 노광을 진행할 수 없음 (단위: %)
; SCALE_RATE            = 주어진 값 범위 내에서 등록된 마크와 가장 유사한 즉, Score 값이 가장 높은
;                         결과를 추출해 냄 (범위가 크면 클수록 검색 대상이 많아짐) (단위: %)
;                         만약 이 값이 90이면, 검색 범위 = 1.0 - (100.0 - 90.0) / 100.0 임 즉,
;                         검색 범위는 1.0 기준으로 +/- 검색 범위 값임 (최소 값은 50 임)
; MODEL_SPEED           = 모델의 검색 속도 지정 (0:Very Low / 1:Low / 2:Medium / 3:High / 4:Very High)
;                         (모델 크기가 작거나 매칭률에서 높은 정확성을 필요로 하거나,
;                          모델의 에지가 기하학적으로 복잡한 경우에는 디폴트 설정 (M_MEDIUM) 사용)
; MODEL_SMOOTH          = 기본 값은 75.0이며, 경계선의 Noise 값을 얼마다 부드럽게 처리하는 정도이며,
;                         값의 범위는 (0.0 ~ 100.0) 즉, 경계선 구분이 어려울 수록 값이 크면 좋다(?)
;                         0 값이면, 기본 값 (보통 50) (!!! 이미지의 노이즈 감소 시키는데 유용 !!!)
; DETAIL_LEVEL          = 등록된 모델 이미지와 Grabbed Image이미지의 Edge 영역에 대한 비교 정도 값
;                         값이 클수록 상세히 비교하지만, 속도는 많이 느려지짐
;                         LOW보다 HIGH로 갈수록 더 많은 Edge를 가지고 비교하게 됨
;                         0 (M_HIGH), 1 (M_MEDIUM), 2 (M_VERY_HIGH)
;
; MIXED_DIST_LIMIT      = 복합 얼라인 마크의 경우, Hole과 Laser 간의 중심 마크 간의
;                         최대 허용 오차 간격 (단위: mm) (소수점 3자리까지 유효) (최대 값. 255)
; MIXED_SQUARE_RATE     = 다점 얼라인 마크의 주변 (Side)의 사각형 가로/세로 비율 값이 이 값
;                         (비율. 단위: %) 이내에
;                         있는지 판단을 위한 비율 값 (단위 : um) 즉, 가로/세로 크기가
;                         얼마나 정사각형인지 판단
;                         만약 이 값이, 100이면 주변 (Side) 마크의 가로 / 세로 크기가 완전한
;                         정사각형으로 구성
;                         만약 이 값이,  50이면 주변 (Side) 마크의 가로 / 세로 크기가 직사각형
;                         구조 즉, 가로 (혹은 세로)가 세로 (혹은 가로) 보다 50% 이상 크면 유효
; MIXED_WEIGHT_RATE     = 복합 얼라인 마크 사용될 때, 적용되는 가중치 값 (1 ~ 100) (단위: %)
; MIXED_MARK_CENT_TYPE  = Mixed Mark (Multi-Mark)의 중심 구하는 방식 설정
;                         0: 검색된 마크들의 Min/Max 좌표를 구한 후 사각형의 중심 값을 좌표로 설정
;                         1: 검색된 마크들의 다각형 좌표에 대한 무게 중심 값을 좌표로 설정
;-------------------------------------------------------------------------------------------------

[MARK_FIND]

MAX_MARK_REGIST         = 4
MAX_MARK_GRAB           = 2
MAX_MARK_FIND           = 1

SCORE_RATE              = 75.0000
SCALE_RATE              = 80.0000
MODEL_SMOOTH            = 80.0000
MODEL_SPEED             = 1
DETAIL_LEVEL            = 1

MIXED_DIST_LIMIT        = 0.100
MIXED_SQUARE_RATE       = 50
MIXED_WEIGHT_RATE       = 90
MIXED_MARK_CENT_TYPE    = 1

;-------------------------------------------------------------------------------------------------
; [EDGE_FIND]
;
; MAX_FIND_COUNT        = 최대 검색할 수 있는 개수 (최대 MAX_UINT32 넘으면 안됨)
; 아래 2개의 변수는 현재 사용하지 말것. (어렵다)
; MIN_DIA_LENGTH        = 최소 검색 크기 (원의 지름) (단위: mm) (소수점 3자리까지 유효)
;                         실제 검색되는 이미지의 경우, 각종 노이즈, 배율에 따라 작아질 수 있으므로,
;                         보통 이 값에 10% 덜 잡아 준다. (프로그램 내부적으로)
;                         최대한 많이 검색된 결과 값을 얻으려면, 값을 최소한으로 하면 됨
; MAX_DIA_LENGTH        = 최대 검색 크기 (원의 지름) (단위: mm) (소수점 3자리까지 유효)
;                         실제 검색되는 이미지의 경우, 각종 노이즈, 배율에 따라 커질수 있으므로,
;                         보통 이 값에 10% 더 잡아 준다. (프로그램 내부적으로)
;                         !!! 호의 길이 = 지름 * 원주율 (3.14159....)
;
; THRESHOLD             = 1 : Very High, 2 : High, 3 : Medium, 4 : Low, 5 : Disable
;                         일반적인 조명 상태의 이미지에서 기본 값인 High로도 Edge 추출하는데
;                         큰 문제가 없지만, 불균일한 밝기의 이미지에서 Edge 추출 시 High 설정하면
;                         사라지는 Edge 들이 많습니다. 이러한 경우에 Medium으로 설정하는 것이
;                         효율적입니다. Disable 값으로 설정하면, 대부분의 Edge들이 검출됨
; FILTER_TYPE           = 1:SHEN or 2:DERICHE, 3:PREWITT, 4:SOBEL, 5:FREICHEN
;                         SHEN      - 기본 필터로서, 전반적으로 이상적이며, 매우 좋은 위치의 Edge를
;                                     추출하는데 효과적이지만, 때때로 노이즈에 대해 예기치 않게
;                                     민감하거나 비정상적으로 두꺼운 Crest를 추출하는데 부적절한
;                                     결과를 얻을 수 있다.
;                         DERICHE   - Shen보다 Edge의 이웃에 더 중점을 두고 있기 때문에,
;                                     이런 문제에 대해 Deriche를 사용해야 함
; FILTER_SMOOTHNESS     = FILTER 검색 조건 값 (기본값 : 75, 최대 100, 기본 값 : 50 설정됨)
;                         0 ~ 100으로 지정하며, 100에 가까울 수록 엣지 강도가 센 것만 추출 함
;                         (최대 값이면 좋음)
; M_EXTRACTION_SCALE    = ? (1 or later) (기본 값은 1.0) (0 값이면 기본 값으로 설정됨)
;                         (소수점 6자리까지 유효)
; M_MOMENT_ELONGATION   = 0.1 ~ 1.0 이며, 1.0에 가까울 수록 Low elongation,
;                         0.0에 가까울수록 High elongation으로 간주됨 (소수점 6자리까지 유효)
;                         쉽게 설명하면, 정원(동그란 원)을 No elongation이라고 생각하면,
;                         원이 눌려져서 옆으로 늘어나게 될 수록 High elongation으로 변환된다고
;                         생각하면 됨. 다르게 설명하는 곳은, 시작 점과 끝 점이 연결되는 강도가
;                         주어진 값보다 작으면 배제 1.0일 경우, 완전히 연결된 모습이고,
;                         1.0이하인 경우, 시작 점과 끝점이 완전히 연결 안되어진 경우를 말함
;                         (변형률이라고도 함) 혹은 [장축과 단축의 비] / 0 값이면 사용 안함
; M_ACCURACY            = -9999 (Disable), 3 (Default:High), 4 (Very High)
; MARK_SPARE_SIZE       = 기존 엣지를 통해 검색된 마크 크기에 추가로 더 해주는 크기 (단위: mm)
;                         (소수점 3자리까지 유효)
;                         엣지로 검색된 마크 크기가 실제 찾기 시도할 때, 조금 적게 되는 현상
;                         +500 ~ -500 사이의 값이어야 함 (ring model의 음수 값은 신중(자제)해야 됨)
;                         이 설정 값이 [양수]이고 ring인 경우, inner 쪽은 줄어들고,
;                         outer 쪽은 늘어난다.
;                         이 설정 값이 [음수]이고 ring인 경우, inner 쪽은 늘어나고, outer 쪽은
;                         줄어든다.
; GAUSSIAN_FILTER       = 가우시안 필터 값 (0 : 사용하지 않음)
;                         1 : EDGE_DETECT, 2 : EDGE_DETECT2, 3 : M_HORIZ_EDGE, 4 : M_LAPLACIAN_EDGE,
;                         5 : M_LAPLACIAN_EDGE2, 6 : M_SHARPEN, 7 : M_SHARPEN2, 8 : M_SMOOTH,
;                         9 : M_VERT_EDGE,
; FILL_GAP_CONTINUITY   = 0 ~ 100 (0 값이면, 가장 인접한 점끼리 선 연결,
;                                  100이면, 가장 곡면이 매끄러운 점끼리 연결)  (소수점 3자리까지 유효)
; USE_FLOAT_MODE        = Sub Pixel에 대해 부동 소숫점 연산을 사용할 것인지 여부 (정밀 계산 여부?)
;                         0 : Disable, 1 : Enable
; USE_CLOSED_LINE       = 엣지들끼리 연결된 완전체 도형 모습만 추출할 것인지 여부 (0: NO, 1: YES)
; INC_INTERNAL_EDGE     = 내부 엣지 검색 정보들 포함 여부 (0: 미포함, 1: 포함)
; EDGE_ANALYSIS_SAVE    = 1 : 분석된 이미지 저장 (edge), 0 : 분석된 이미지 저장 안함
;-------------------------------------------------------------------------------------------------

[EDGE_FIND]

MAX_FIND_COUNT          = 65535
MIN_DIA_LENGTH          = 100.000
MAX_DIA_LENGTH          = 2500.000

THRESHOLD               = 1
FILTER_TYPE             = 1
FILTER_SMOOTHNESS       = 75
M_EXTRACTION_SCALE      = 0.000000
M_MOMENT_ELONGATION     = 0.000000
M_ACCURACY              = 3
MARK_SPARE_SIZE         = 0.000
GAUSSIAN_FILTER         = 0
FILL_GAP_CONTINUITY     = 55.000
USE_FLOAT_MODE          = 0
USE_CLOSED_LINE         = 0
INC_INTERNAL_EDGE       = 1
EDGE_ANALYSIS_SAVE      = 1

;-------------------------------------------------------------------------------------------------
; [LINE_FIND]
;
; MAX_FIND_COUNT        = Line Edge 검색할 대상의 최대 개수. 보통 4개이나, 더 많을 수도 있음
; PART_EXPOSE_REPEAT    = 0 : 분할 노광일 경우, 첫 분할 노광일 때만 엣지 검출작업 진행
;                         1 : 분할 노광일 경우, 매 분할 노광일 때마다 엣지 검출작업 진행
;
; EDGE_FIND_OPTION      = 0 : 검출된 엣지 중에서 이미지 중심에서 가장 가까운 값 기준
;                         1 : 검출된 엣지 중에서 Edge Strength가 가장 큰 값 기준
;                         2 : 검출된 엣지 중에서 이미지 중심에서 가장 가깝고,
;                             Edge Strength가 가장 큰 값 기준
;                         3 : 검출된 엣지의 개수가 오로지 1개이면 정상 노광,
;                             2개 이상이면 물어보는 창 출력
;
; TEXT_FONT_NAME        = 엣지 라인 검색 결과 값이 출력되는 폰트 이름 (Max. 31)
; TEXT_FONT_SIZE        = 엣지 라인 검색 결과 값이 출력되는 폰트 크기 (단위: 1 ~ 63). 보통 20
;
; GRAB_IMAGE_EDGE_ANGLE = Grabbed Image의 엣지 검사할 때 검사 기준 각도 (큰 의미는 없음)
; PRINT_DIFF_LIMIT      = 노광 시작 위치와 Edge Line 검색 결과 위치 간의 거리 오차 한계 (단위: mm)
;                         절대 값 (노광 시작 위치 - Edge Line 검색 결과 위치
;                                  (모션 검사 시작 위치 계산)) (소숫점 3자리까지 유효)
;                         즉, 노광 시작 위치와 검색된 위치 간의 거리 간격이 이 값보다 크면
;                         소재 뒤틀림이 심함. 최대 입력 가능한 값 (Max: 2000 um)
;
; SEARCH_REGION_CLIP    = 이미지 밖의 영역으로 검색 영역이 벗어난 경우, 자동으로 이미지 안쪽으로
;                         검색 영역을 선택하도록 할 것인지 여부 (0 or 1)
; BOX_SIZE_WIDTH        = 검사 영역 크기 (단위: %)
;                         (값의 범위는 15 ~ 85 이면, 값이 클수록 이미지 넓이와 동일해짐)
; BOX_SIZE_HEIGHT       = 검사 영역 크기 (단위: %)
;                         (값의 범위는 15 ~ 85 이면, 값이 클수록 이미지 높이와 동일해짐)
;
; FILTER_TYPE           = 0:EULER (Default), 1:PREWITT, 2:SHEN
;                         EULER   : 처리속도는 PREWITT에 의해 빠르지만 노이즈에는 약함
;                                   (kernel size:2)
;                         PREWITT : 처리속도는 EULER보다 느리지만 노이즈에 덜 민감함
;                                   (kernel size:3)
;                         SHEN    : 재귀호출 지원을 하며, kernel size는 이론적으로 제한 없음
;                                   노이즈 강하지만, EULER/PREWITT에 비해 상대적으로 처리속도 느림
;                                   추가적으로 FILTER_SMOOTHNESS와 결합하여 가장 좋은 결과 얻어냄
; FILTER_SMOOTHNESS     = 노이즈 제거 작업 수행 (0 ~ 100) 단, FILTER_TYPE = SHEN인 경우만 유효
; EDGE_THRESHOLD        = 기본 값 2 (0 ~ 100)
;                         값이 작아지면, 영역을 구분하는 엣지 개수가 증가하므로, 검색 속도 느려짐
;                                        반면에, 좀더 정확한 엣지 검색이 됨
;
; POLARITY              = 0: NULL (적용 (사용) 하지 않음)
;                         1: ANY (고려하지 않음. 사용하지 않는 것과는 다른 의미)
;                         2: POSITIVE (rising edge. 어두운 곳에서 밝은 곳. 0:Black -> 255:White)
;                         3: NEGATIVE (falling edge. 밝은 곳에서 어두운 곳. 255:White -> 0:Black)
;
; SUB_REGIONS_OFFSET    = SubRegions의 위치 조절 비율 (-100% ~ 0 ~ +100%)
; SUB_REGIONS_SIZE      = SubRegions의 크기 조절 (1 ~ 100%) 보통 50% 이상으로 하면 좋다 (?)
; SUB_REGIONS_NUMBER    = SubRegions의 개수 조절 (1 or Later. Max 100)
;                         참고로, SUB_REGIONS_SIZE와 NUMBER의 곱이 100을 넘으면 안됨
;                         (될 수 있으면, 곱이 100이 나오도록 설정해주면 좋음)
;                         BOX_SIZE 영역에서 SIZE 크기씩 NUMBER 개수만큼 검색하라는 뜻임
; ORIENTATION           = 검색 방향 (극성)
;                         1: ANY (마커 (검색) 방향을 알 수 없다?)
;                         2: HORIZONTAL (수평으로, 위에서 아래로 검색)
;                         3: VERTICAL (수직으로, 왼쪽에서 오른쪽으로 검색)
; BOX_ANGLE_MODE        = 0: 오로지 BOX_ANGLE에서 설정된 값에 의해 수행
;                         1: BOX_ANGLE을 포함한 다양한 각도 검색 방법을 수행할 수 있음
; BOX_ANGLE             = Box search region의 각도 설정 즉, 검색 영역의 사각형 박스의 회전 각도 값
;                         엣지 검색 대상의 영역을 몇 도로 회전할 것인지 값 (0 ~ 360) 보통 0
; BOX_ANGLE_ACCURACY    = Marker의 대략적인 위치 찾은 후, 상세히 검색할 각도의 Step 크기
;                         (0.1 ~ 180.0)
;                         0.0 값을 입력한 경우,
;                                   DISABLE로서 Tolerance (허용 오차) 각도와 동일한 크기가 입력됨
; 아래 2개는 결국, (BOX_ANGLE - BOX_ANGLE_DELTA_NEG) ~ (BOX_ANGLE + BOX_ANGLE_DELTA_POS) 까지 검색
; BOX_ANGLE_DELTA_NEG   = BOX_ANGLE 기준으로 이 값 이전 각도부터 검색 수행 (0 ~ 180)
; BOX_ANGLE_DELTA_POS   = BOX_ANGLE 기준으로 이 값 이후 각도까지 검색 수행 (0 ~ 180)
;-------------------------------------------------------------------------------------------------

[LINE_FIND]

MAX_FIND_COUNT          = 4
PART_EXPOSE_REPEAT      = 1

EDGE_FIND_OPTION        = 0

TEXT_FONT_NAME          = D2Coding
TEXT_FONT_SIZE          = 20

GRAB_IMAGE_EDGE_ANGLE   = 180.000
PRINT_DIFF_LIMIT        = 1000.000

SEARCH_REGION_CLIP      = 0
BOX_SIZE_WIDTH          = 85
BOX_SIZE_HEIGHT         = 85
FILTER_TYPE             = 2
FILTER_SMOOTHNESS       = 25
EDGE_THRESHOLD          = 3
POLARITY                = 3
SUB_REGIONS_OFFSET      = 0
SUB_REGIONS_SIZE        = 100
SUB_REGIONS_NUMBER      = 1
ORIENTATION             = 3
BOX_ANGLE_MODE          = 1
BOX_ANGLE               = 0
BOX_ANGLE_ACCURACY      = 0.50
BOX_ANGLE_DELTA_NEG     = 25
BOX_ANGLE_DELTA_POS     = 25

;-------------------------------------------------------------------------------------------------
; [ACAM_SPEC]           : 얼라인 카메라 사양 조사에 필요한 파라미터 (QuartZ 기준)
;                         !!! QuartZ 기준으로 측정 !!!
;
; POINT_DIST            = 카메라 FOV 이내에 각도 및 픽셀 크기를 측정하기 위한
;                         두 지점 사이의 거리 값 (단위: mm) (소수점 4자리까지 유효)
; STEP_MOVE_Z           = Focus 측정을 위한 Z Axis (Align Camera) Up/Down 이동 간격
;                        (범위 : 0.001 ~ 1.000, 최대 1 mm, 단위: mm) (소숫점 3자리까지 유효)
; ACAM_Z_FOCUS_x        = Align Camera (Photohead도 포함) 내에 설치된 Camera Z Axis 높이 값
;                         (단위: mm) (단! Photohead의 경우, 단위를 맞추기 위해 곱하기 10 해줌)
;                         (소숫점 4자리까지 유효)
; QUARTZ_STAGE_X        = QuartZ 측정 시작 위치. Stage X (단위: mm) (소숫점 4자리까지 유효)
; QUARTZ_STAGE_Y1       = QuartZ (Align Camera 1번 측정할 때) 측정 시작 위치. Stage Y (단위: mm)
;                       (소숫점 4자리까지 유효)
; QUARTZ_STAGE_Y2       = QuartZ (Align Camera 2번 측정할 때) 측정 시작 위치. Stage Y (단위: mm)
;                       (소숫점 4자리까지 유효)
; QUARTZ_ACAM_1         = QuartZ 측정 시작 위치. ACam 1 (단위: mm) (소숫점 4자리까지 유효)
; QUARTZ_ACAM_2         = QuartZ 측정 시작 위치. ACam 2 (단위: mm) (소숫점 4자리까지 유효)
;
; IN_RING_SIZE          = Quartz Size의 Ring 내부에 있는 원의 크기 (직경) (단위: mm)
;                         (소숫점 3자리까지 유효)
;                         안쪽 Circle : 0.1 mm / 안쪽 Ring : 1.800 mm / 바깥쪽 Ring : 2.000 mm
;                         Quartz Thickness : 6.35 mm (+/- 10um)
; IN_RING_COLOR         = 내부 링의 원을 채우는 색깔 값. 128.0:White, 256.0:Black
; IN_RING_SCALE_MIN     = 내부 링의 찾기 조건 값 (Scale 조건 값) 0.95 (0.5 ~ 1.0)
; IN_RING_SCALE_MAX     = 내부 링의 찾기 조건 값 (Scale 조건 값) 1.05 (1.0 ~ 2.0)
;
; CAM_SPEC_IXEL_UM_x    = 실제 카메라로 측정한 1 픽셀의 크기 값 (단위: um)
; ACAM_ANGLE_x          = 실제 카메라로 측정한 회전 각도 (단위: degree)
; BRACKET_SIZE_W/D      = 얼라인 카메라를 고정하고 있는 브라켓의 가로/세로 튀어나온 영역 (단위: mm)
;
;-------------------------------------------------------------------------------------------------

[ACAM_SPEC]

STEP_MOVE_Z             = 0.050
POINT_DIST              = 1.0000

QUARTZ_STAGE_X          = 264.4970
QUARTZ_STAGE_Y1         = 1452.7712
QUARTZ_STAGE_Y2         = 1453.0332
QUARTZ_ACAM_1           = 570.7655
QUARTZ_ACAM_2           = 420.3508

;22년 7월1일 임시 변경(원본)

;QUARTZ_STAGE_X          = 263.4980
;QUARTZ_STAGE_Y1         = 1453.0680
;QUARTZ_STAGE_Y2         = 1453.1295
;QUARTZ_ACAM_1           = 571.8289
;QUARTZ_ACAM_2           = 421.2594

; 2.0x Lens (2021-07-12) (Coaxial Lamp)
ACAM_ANGLE_1            = -0.10370000
ACAM_ANGLE_2            = -0.02030000
ACAM_PIXEL_UM_1         = 3.01920000
ACAM_PIXEL_UM_2         = 3.06980000
ACAM_Z_FOCUS_1          = -10.7750
ACAM_Z_FOCUS_2          = -12.1500
IN_RING_COLOR           = 256.0
IN_RING_SIZE            = 1.000
IN_RING_SCALE_MIN       = 0.90
IN_RING_SCALE_MAX       = 1.80

; 0.8x Lens (2020-xx-xx) (Ring Lamp) (2019-xx-xx)
;ACAM_ANGLE_1            = -0.1009
;ACAM_ANGLE_2            = -0.0216
;ACAM_PIXEL_UM_1         = 7.3206
;ACAM_PIXEL_UM_2         = 7.3002
;ACAM_Z_FOCUS_1          = -3.2000
;ACAM_Z_FOCUS_2          = -4.1000
;IN_RING_COLOR           = 128.0
;IN_RING_SIZE            = 1.000
;IN_RING_SCALE_MIN       = 0.90
;IN_RING_SCALE_MAX       = 1.10

BRACKET_SIZE_W          = 20.0000
BRACKET_SIZE_D          = 20.0000

;-------------------------------------------------------------------------------------------------
; [ACAM_FOCUS]          : 얼라인 카메라 포커스 검색에 필요한 파라미터 (소재 기준)
;                         !!! 필름 기준으로 측정 !!!
;
; STEP_MOVE_Z           = Focus 측정을 위한 Z Axis (Align Camera) Up/Down 이동 간격
;                        (범위 : 0.001 ~ 1.000, 최대 1 mm, 단위: mm) (소숫점 3자리까지 유효)
; ACAM_Z_FOCUS_x        = Align Camera (Photohead도 포함)의 Z Axis 높이 (Focus) 값 (단위:mm)
;                         [SETUP_ALIGN] - [DOF_FILM_THICK] 두께 기준으로 Z 높이 값
; MARK_STAGE_X          = FILM 측정 시작 위치. Stage X (단위: mm) (소숫점 4자리까지 유효)
; MARK_STAGE_Y1         = FILM (Align Camera 1번 측정할 때) 측정 시작 위치. Stage Y (단위: mm)
;                         (소숫점 4자리까지 유효)
; MARK_STAGE_Y2         = FILM (Align Camera 2번 측정할 때) 측정 시작 위치. Stage Y (단위: mm)
;                         (소숫점 4자리까지 유효)
; MARK_ACAM_1           = FILM 측정 시작 위치. ACam 1 (단위: mm) (소숫점 4자리까지 유효)
; MARK_ACAM_2           = FILM 측정 시작 위치. ACam 2 (단위: mm) (소숫점 4자리까지 유효)
;
; MODEL_DIA_SIZE        = FILM에 노광된 Mark Size의 Circle (원)의 크기 (직경) (단위: mm)
;                         (소숫점 3자리까지 유효)
;
;-------------------------------------------------------------------------------------------------

[ACAM_FOCUS]

STEP_MOVE_Z             = 0.025

; 2.0x (2021-08-24) (170 um) (Coaxial Lamp)
ACAM_Z_FOCUS_1          = -6.4050
ACAM_Z_FOCUS_2          = -7.8000
;ACAM_Z_FOCUS_2          = -7.7450

; 2.0x Lens (2021-08-16) (120 um) (Coaxial Lamp)
;ACAM_Z_FOCUS_1          = -6.4550
;ACAM_Z_FOCUS_2          = -7.7950

; 2.0x Lens (2021-07-12) (Coaxial Lamp)
;ACAM_Z_FOCUS_1          = -4.084
;ACAM_Z_FOCUS_2          = -5.264

; 0.8x Lens (2020-xx-xx) (Ring Lamp)
;ACAM_Z_FOCUS_1          = 1.1200
;ACAM_Z_FOCUS_2          = 0.2550

MARK_STAGE_X            = 0.0000
MARK_STAGE_Y1           = 0.0000
MARK_STAGE_Y2           = 0.0000
MARK_ACAM_1             = 0.0000
MARK_ACAM_2             = 0.0000

MODEL_DIA_SIZE          = 0.100

;-------------------------------------------------------------------------------------------------
; [PH_FOCUS]            : 광학계 포커스 검색에 필요한 파라미터
;
; EXPO_STAGE_X/Y        = 소재에 노광될 위치로 이동하기 위한 Motion 위치 (단위: mm)
;                         (소수점 3자리까지 유효. 광학계에 전달될 위치 임)
; MARK_STAGE_X/Y        = 처음 노광된 마크의 위치로 이동하기 위한 Motion 위치 (단위: mm)
;                         (소수점 4자리까지 유효)
; MARK_ACAM1/2_X        = 처음 노광된 마크의 위치로 이동하기 위한 Motion 위치 (단위: mm)
;                         (소수점 4자리까지 유효)
;
; STEP_MOVE_Y           = Stage Y 방향으로 이동하기 위한 마크와 마크의 이동 간격 (단위: mm)
;                         (소수점 4자리까지 유효)
;                         양수 값 : 전진, 음수 값 : 후진
; STEP_MOVE_Z           = 매 회 노광 때마다, 광학계 Z 축 Up/Down 이동 값 (단위: mm)
;                         (소수점 4자리까지 유효)
; STEP_Y_COUNT          = Stage Y 방향으로 이동하는 총 STEP 개수
;                         STEP_MOVE_Y * STE_MOVE_COUNT = 이 값이 Y 축 최대 이동 거리 넘지 않아야 함
; REPEAT_COUNT          = 매번 측정되는 구간마다 측정 반복 횟수 (최대 65535)
;
; PH_VS_PH_DIST         = Photohead 간의 떨어진 거리 즉, 마크 간 떨어진 폭 거리 (단위: mm)
;                         (소수점 4자리까지 유효)
; MODEL_DIA_SIZE        = 검색된 엣지 객체들 중에서 이 설절 값과 가장 가까운 값을 인정 (단위: mm)
;                         (소수점 3자리까지 유효) (검색 대상은 무조건 원. !!! 지름 !!!)
; MODEL_COLOR           = 128 (흰색), 256 (검정색)
;-------------------------------------------------------------------------------------------------

[PH_FOCUS]

EXPO_STAGE_X            = 15.000
EXPO_STAGE_Y            = 52.000
MARK_STAGE_X            = 159.9994
MARK_STAGE_Y            = 750.2978
MARK_ACAM1_X            = 434.4485
MARK_ACAM2_X            = 436.9230

STEP_MOVE_Y             = 4.0000
STEP_MOVE_Z             = 0.0500
STEP_Y_COUNT            = 6
REPEAT_COUNT            = 10

PH_VS_PH_DIST           = 103.4700

MODEL_DIA_SIZE          = 1.500
MODEL_COLOR             = 256.000

;-------------------------------------------------------------------------------------------------
; [PH_STEP]             : 광학계 단차 측정에 필요한 파라미터
;
; MAX_PH_STEP           = 레시피에 최대 등록 가능한 단차 개수 즉, 등록된 라인 수 (Max.255)
;                         현재는 내부적으로 사용되고 있지 않은 환경 변수 (내부적으로 최대 255개)
; MODEL_TYPE            = Circle (8), Ellipse (16), Square (32), Rectangle (64), Ring (256),
;                         Cross (8192), Diamond (32768), Triangle (65536), Image (?????)
; MODEL_COLOR           = Black (256), White (128)
; MODEL_DIA_SIZE        = 검색된 엣지 객체들 중에서 이 설절 값과 가장 가까운 값을 인정 (단위: mm)
;                         (소수점 3자리까지 유효) (검색 대상은 무조건 원. 크기는 !!! 지름 !!!)
; MODEL_COLOR           = 128 (흰색), 256 (검정색)
; MARK_STAGE_X/Y        = 처음 노광된 마크의 위치로 이동하기 위한 Motion 위치 (단위: mm)
;                         (소수점 4자리까지 유효)
; MARK_ACAM1_X          = 처음 노광된 마크의 위치로 이동하기 위한 Motion 위치 (단위: mm)
;                         (소수점 4자리까지 유효)
; SCROLL_MODE           = 광학계 단차 측정에 사용된 소재의 노광 속도 모드 (1 ~ 7)
; STRIPE_WIDTH          = 광학계가 한 번 노광할 때마다 그려지는 STRIPE의 크기 (단위: mm)
;                         즉, 2개의 마크 영역이 출력되는 간격 임 (!!! 중요 !!!)
; PH_SCAN               = Photohead마다 동작되는 Scan 횟수 (VSTEP 에서 사용됨)
;                         SCAN 횟수라기보다, 정확히는 2개의 Strip 간의 단차 측정 구간 개수
; MARK_PERIOD           = 2 개의 Mark 간의 떨어진 간격 (단위: mm) (소수점 4자리까지 유효)
; CENTER_OFFSET         = 2 개의 Mark 간의 중심 오차 검색 값.
;                         (이 값이 클수록 빨리 검색하나, 정확도는 떨어짐. 최소 100um 이상)
;-------------------------------------------------------------------------------------------------

[PH_STEP]

MAX_PH_STEP             = 64

MODEL_TYPE              = 8
MODEL_DIA_SIZE          = 1.000
MODEL_COLOR             = 256.000

MARK_STAGE_X            = 160.0000
MARK_STAGE_Y            = 764.3190
MARK_ACAM1_X            = 415.2570

SCROLL_MODE             = 1
STRIPE_WIDTH            = 10.3600

PH_SCAN                 = 20
MARK_PERIOD             = 2.0000
CENTER_OFFSET           = 0.5000

;-------------------------------------------------------------------------------------------------
; [ACAM_CALI]           : 얼라인 카메라의 위치 별 모션 보정 값
;
; SET_MATCH_MODE        = 단일 마크 검색 대상. 0 : Circle 검색, 1 : Ring 검색
;                         멀티 검색일 경우, Circle, Ring 2개 등록 됨 (Inspection 동작일 경우)
;
; MAX_ROWS_COUNT        = X 축으로 모션 이동하면서 측정할 수 있는 최대 개수
; MAX_COLS_COUNT        = Y 축으로 모션 이동하면서 측정할 수 있는 최대 개수
; MIN_PERIOD_SIZE       = X/Y 축으로 이동할 때, 이동 최소 거리 (단위: mm) (소숫점 4자리까지 유효)
;
; Shutting (Inspection) 및 Calibration 전용
; MODEL_SHUT_TYPE       = Circle (8), Ellipse (16), Square (32), Rectangle (64), Ring (256),
;                         Cross (8192), Diamond (32768), Triangle (65536), Image (?????)
; MODEL_SHUT_COLOR      = Black (256), White (128)
; MODEL_SHUT_SIZE       = 원 (Circle)의 크기 (!!! 반지름 !!!) (단위: mm)
;                         (소수점 3자리까지 유효)
;
; MODEL_RING_COLOR      = Black (256), White (128)
; MODEL_RING_SIZE1      = 도넛 (Ring)의 내부 크기 (!!! 반지름 !!!) (단위: mm)
; MODEL_RING_SIZE2      = 도넛 (Ring)의 외부 크기 (!!! 반지름 !!!) (단위: mm)
;                         (소수점 3자리까지 유효)
; ; Align Camera 2D Calibration or Stage XY 2D Calibration에 따라서 달라짐
; MARK_STAGE_X          = Align Calibration 측정 시작 위치. Stage X  (단위: mm)
;                        (소수점 4자리까지 유효)
; MARK_STAGE_X1/2       = Align Calibration 측정 시작 위치. Stage X  (단위: mm)
;                        (소수점 4자리까지 유효)
; MARK_STAGE_Y1         = Align Calibration (Align Camera 1번 측정할 때) 측정 시작 위치
;                        Stage Y (단위: mm) (소수점 4자리까지 유효)
; MARK_STAGE_Y2         = Align Calibration (Align Camera 2번 측정할 때) 측정 시작 위치
;                        Stage Y (단위: mm) (소수점 4자리까지 유효)
; MARK_ACAM_1           = Align Calibration 측정 시작 위치. ACam 1 (단위: mm)
;                        (소수점 4자리까지 유효)
; MARK_ACAM_2           = Align Calibration 측정 시작 위치. ACam 2 (단위: mm)
;                        (소수점 4자리까지 유효)
; PERIOD_WAIT_TIME      = Calibration 측정하기 전 모터가 멈추가 난 이후
;                         안정될 때까지 최소 대기 시간 (단위: ms) (최소 값이 100)
;
; SCALE_VALID_RATE      = 찾고자 하는 마크의 크기 비율 값이 1.0 값 기준으로,
;                         이 값 오차 (+/-) 내에 있어야 됨 (보통 0.1 값 정도 주면 됨)
;                         (소수점 4자리까지 유효)
; SCORE_VALID_RATE      = 찾고자 하는 Model의 매칭 비율 값이 이 값 보다 높아야 됨 (보통 90.0000)
;                         이 값은 % 값으로 설정. 즉 95% 수준 이상 찾길 원하면 95.0000
;                         (소수점 4자리까지 유효)
; MOTION_SPEED          = Camera 1, Stage X, Stage Y 측정 이동 속도 (unit: mm / sec)
;                         (소수점 4자리까지 유효)
; ERR_LIMIT_VALUE       = 오차 한계 값 즉, 이 값이 벗어나면, 에러 값으로 판단 (단위: mm)
;                         프로그램의 그리드 영역에서 측정된 배경 (CELL)에 "연두색" 표현
;-------------------------------------------------------------------------------------------------

[ACAM_CALI]

SET_MATCH_MODE          = 0

MAX_ROWS_COUNT          = 120
MAX_COLS_COUNT          = 150
MIN_PERIOD_SIZE         = 5.0000

PERIOD_WAIT_TIME        = 250

MODEL_SHUT_TYPE         = 8
MODEL_SHUT_SIZE         = 1.3000
MODEL_SHUT_COLOR        = 256.000

MODEL_RING_TYPE         = 256
MODEL_RING_SIZE1        = 1.9000
MODEL_RING_SIZE2        = 2.5000
MODEL_RING_COLOR        = 256.000

;MODEL_SHUT_TYPE         = 8
;MODEL_SHUT_SIZE         = 1.0000
;MODEL_SHUT_COLOR        = 256.000

;MODEL_RING_TYPE         = 256
;MODEL_RING_SIZE1        = 2.0000
;MODEL_RING_SIZE2        = 2.5000
;MODEL_RING_COLOR        = 256.000

; Align Camera 2D Calibration(0715슈팅검증)
MARK_STAGE_X            = 163.3932
MARK_STAGE_Y1           = 766.8489
MARK_STAGE_Y2           = 752.2136
MARK_ACAM_1             = 406.0045
MARK_ACAM_2             = 257.8160
; Align Camera 2D Calibration
;MARK_STAGE_X            = 159.5959
;MARK_STAGE_Y1           = 746.9065
;MARK_STAGE_Y2           = 747.2153
;MARK_ACAM_1             = 411.0683
;MARK_ACAM_2             = 261.0172

; Stage XY 2D Calibration
;MARK_STAGE_X1           = 160.0000
;MARK_STAGE_X2           = 240.0000
;MARK_STAGE_Y1           = 747.1595
;MARK_STAGE_Y2           = 747.2153
;MARK_ACAM_1             = 485.0000
;MARK_ACAM_2             = 485.0000

SCORE_VALID_RATE        = 30.0000
SCALE_VALID_RATE        = 0.1000

MOTION_SPEED            = 50.0000

ERR_LIMIT_VALUE         = 0.0030

;-------------------------------------------------------------------------------------------------
; [STAGE_ST]           : Stage XY 진직도
;
; MODEL_MEAS_COLOR      = Black (256), White (128)
; MODEL_MEAS_SIZE       = 원 (Circle)의 크기 (!!! 반지름 !!!) (단위: mm)
;                         (소수점 3자리까지 유효)
;
; SCALE_VALID_RATE      = 찾고자 하는 마크의 크기 비율 값이 1.0 값 기준으로,
;                         이 값 오차 (+/-) 내에 있어야 됨 (보통 0.1 값 정도 주면 됨)
;                         (소수점 4자리까지 유효)
; SCORE_VALID_RATE      = 찾고자 하는 Model의 매칭 비율 값이 이 값 보다 높아야 됨 (보통 90.0000)
;                         이 값은 % 값으로 설정. 즉 95% 수준 이상 찾길 원하면 95.0000
;                         (소수점 4자리까지 유효)
; MOTION_SPEED          = Camera 1, Stage X, Stage Y 측정 이동 속도 (unit: mm / sec)
;                         (소수점 4자리까지 유효)
; ERR_LIMIT_VALUE       = 오차 한계 값 즉, 이 값이 벗어나면, 에러 값으로 판단 (단위: mm)
;                         프로그램의 그리드 영역에서 측정된 배경 (CELL)에 "연두색" 표현
;-------------------------------------------------------------------------------------------------

[STAGE_ST]

MODEL_MEAS_SIZE         = 1.0000
MODEL_MEAS_COLOR        = 128.000

SCORE_VALID_RATE        = 50.0000
SCALE_VALID_RATE        = 0.2000

MOTION_SPEED            = 50.0000

ERR_LIMIT_VALUE         = 0.0030

;-------------------------------------------------------------------------------------------------
; [TEMP_RANGE]          Temprature & Range
;
; 아래 온도 설정 값은 Range 설정 값보다 항상 2배 이상 크게 설정해야 함
; HOT_AIR_DEV_TEMP      = Hot Air (온조기) 설정 온도 값 (단위: ℃)
; HOT_AIR_DEV_RANGE     = Hot Air (온조기) 오차 범위 값 (단위: ℃) (+/- Range Value)
; HOT_DI_DEV_TEMP       = DI Internal 설정 온도 값 (단위: ℃)
; HOT_DI_DEV_RANGE      = DI Internal 오차 범위 값 (단위: ℃) (+/- Range Value)
; HOT_PH_LED_TEMP       = PHOTOHEAD LED 설정 온도 값 (단위: ℃)
; HOT_PH_LED_RANGE      = PHOTOHEAD LED 오차 범위 값 (단위: ℃) (+/- Range Value)
; HOT_PH_BOARD_TEMP     = PHOTOHEAD BOARD 설정 온도 값 (단위: ℃)
; HOT_PH_BOARD_RANGE    = PHOTOHEAD BOARD 오차 범위 값 (단위: ℃)
;-------------------------------------------------------------------------------------------------

[TEMP_RANGE]

HOT_AIR_DEV_TEMP        = 21.0
HOT_AIR_DEV_RANGE       = 5.0
HOT_DI_DEV_TEMP         = 22.0
HOT_DI_DEV_RANGE        = 3.0
HOT_PH_LED_TEMP         = 28.0
HOT_PH_LED_RANGE        = 12.0
HOT_PH_BOARD_TEMP       = 28.5
HOT_PH_BOARD_RANGE      = 8.0

;----------------------------------------------------------------------------------------------------
; [AUTO_HOT_AIR]        DI 내부 온도가 주어진 RANGE 값을 벗어난 경우, 자동 조정
;
; USE_AUTO_HOT_AIR      = 0:온조기 온도 자동 제어 안함. 1:온조기 온도 자동 제어 함
;                         [PODIS_COMN] -> CHECK_HOT_AIR 값이 1 로 설정되어 있어야 의미가 있음
; AUTO_TEMP_RANGE       = [TEMP_RANGE]->HOT_DI_DEV_TEMP 설정 온도 값과 현재 DI 내부 온도 값의
;                         차이가 이 (AUTO_TEMP_RANGE)값 보다 크면, 자동 제어 수행 함 (최대값 10. 실수)
;                         온도 제어 정밀도는 소숫점 1자리까지만 가능함 (온조기 특성임)
;                         ex> [TEMP_RANGE] -> HOT_DI_DEV_TEMP 값이 22.0 ℃, HOT_DI_DEV_RANGE = 2.0 ℃ 이면,
;                             [AUTO_HOT_AIR] -> AUTO_TEMP_RANGE 값이 2.0 ℃ 로 설정된 상태로 가정.
;                             현재 DI 내부 실시간 온도가 25.0 ℃ 라면, ABS(22.0 ℃ - 25.0 ℃) = 3.0 ℃ 로,
;                             [TEMP_RANGE] -> HOT_DI_DEV_RANGE 설정 (2.0 ℃) 보다 크므로, 자동 제어 수행
; AUTO_TEMP_RATE        = ABS(22.0 ℃ - 25.0 ℃) = -3.0 ℃ 로, 여기서 -3.0 ℃ 값에,
;                             이 설정 값 (백분위; %)을 곱해서, 온조기 설정 (기준)값에 더 해주면 됨
;                         ex> [TEMP_RANGE] -> HOT_DI_DEV_TEMP (22.0 ℃), DI 현재 내부 온도 값 (25.0 ℃)이고,
;                             AUTO_TEMP_RATE 값이 50 % 이라면 => abs(21.0 - 25.0) = -4.0 ℃ 이고,
;                             -4.0 ℃ x 0.5 (50%) = -2.0 ℃ 이므로, DI 내부 온도가 올라가 있으므로,
;                             최종 온조기 설정 값은 21.0 ℃ - 2.0 ℃ = 19.0 ℃ 로 설정 (최대값 100. 정수)
; TEMP_HOLDING_TIME     = DI 내부 온도 차이 값이 이 (TEMP_MONITOR_TIME)시간 (단위: minute)동안 유지되면,
;                         온조기 온도 자동 제어 (최대 값 60)
;                         ex> TEMP_MONITOR_TIME 값이 5 min로 설정되어 있다면,
;                             [TEMP_RANGE] -> HOT_DI_DEV_TEMP 값과 현재 DI 내부 온도 값이 3.0 ℃ 이상
;                             차이가 5 min 이상동안 유지되면, 온조기 온도 설정이 자동으로 제어 됨
;----------------------------------------------------------------------------------------------------

[AUTO_HOT_AIR]

USE_AUTO_HOT_AIR        = 0
AUTO_TEMP_RANGE         = 0.2
AUTO_TEMP_RATE          = 50
TEMP_HOLDING_TIME       = 5

;-------------------------------------------------------------------------------------------------
; [GLOBAL_TRANS]       Global Transformation Information
;
; USE_TRANS             = 0: 아래 파라미터 사용 안함, 1: 아래 파라미터 사용함
;
; USE_xxxx              = 아래 3가지 동작 사용 여부
;
; VAL_ROTATION          = Recipe Rotation (unit : degree)
; VAL_SCALING           = Recipe Scaling (unit : mm)
; VAL_OFFSET            = Recipe Offset (unit : mm)
;-------------------------------------------------------------------------------------------------

[GLOBAL_TRANS]

USE_TRANS               = 0

USE_RECTANGLE           = 0
USE_ROTATION            = 0
USE_SCALING             = 0
USE_OFFSET              = 0

VAL_ROTATION            = 0.000
VAL_SCALING_X           = 0.000000
VAL_SCALING_Y           = 0.000000
VAL_OFFSET_X            = 0.000000
VAL_OFFSET_Y            = 0.000000
[LED_POWER]
MEASURE_POS1_X= 0.0000
MEASURE_POS1_Y= 0.0000
MEASURE_POS1_Z= 0.0000
MEASURE_POS2_X= 0.0000
MEASURE_POS2_Y= 0.0000
MEASURE_POS2_Z= 0.0000
MEASURE_POS3_X= 0.0000
MEASURE_POS3_Y= 0.0000
MEASURE_POS3_Z= 0.0000
MEASURE_POS4_X= 0.0000
MEASURE_POS4_Y= 0.0000
MEASURE_POS4_Z= 0.0000
MEASURE_POS5_X= 0.0000
MEASURE_POS5_Y= 0.0000
MEASURE_POS5_Z= 0.0000
MEASURE_POS6_X= 0.0000
MEASURE_POS6_Y= 0.0000
MEASURE_POS6_Z= 0.0000
BEGIN_POWER_INDEX= 0
MEASURE_COUNT= 0
INTERVAL_POWER= 0
MAX_POINTS= 0
PITCH_POS= 0.0000
FOCUS_SCAN_POS= 0.0000
STAGE_SPEED= 0.000
HEAD_SPEED= 0.000
MANUAL_POWER_INDEX= 0
