
/*
 desc : Luria Config Information
*/

#pragma once

#include "conf_comn.h"

#if (CUSTOM_CODE_PODIS_LLS10 == DELIVERY_PRODUCT_ID || \
	 CUSTOM_CODE_PODIS_LLS06 == DELIVERY_PRODUCT_ID)
#include "conf_podis.h"
#elif (CUSTOM_CODE_GEN2I == DELIVERY_PRODUCT_ID)
#include "conf_gen2i.h"
#endif


/* --------------------------------------------------------------------------------------------- */
/*                                           상수 값                                             */
/* --------------------------------------------------------------------------------------------- */

#define LURIA_PROTOCOL_VERSION					0x01					/* Luria Protocol Version */

#define	MAX_CMD_FAMILY_ID						0x0B /* 0xA0 ~ 0xAB */	/* Family ID 최대 개수 */
#define	MAX_CMD_USER_ID							0x40 /*64*/				/* Family ID 내의 최대 User ID 개수 */
#define USE_SIMULATION_DIR						0						/* 사용 여부 */

#define MIRROR_PERIOD_UM						0.062068				/* DMD 내 Mirror와 Mirror 간의 설치 간격 */

/* --------------------------------------------------------------------------------------------- */
/*                                       전역(Global) 열거형                                     */
/* --------------------------------------------------------------------------------------------- */

/* Packet Function Type : Get or Set */
typedef enum class __en_luria_packet_get_set__ : UINT8
{
	en_set		= 0x00,
	en_get		= 0x01,
	en_set_only	= 0x02,

}	ENG_LPGS;

/* Luria Client or Luria Server */
typedef enum class __en_luria_system_server_client__ : UINT8
{
	en_server	= 0x00,
	en_client	= 0x01,

}	ENG_LSSC;

/* Optic Product ID */
typedef enum class __en_luria_photohead_product_id__ : UINT32
{
	en_lls_2500	= 16702,	/* LLS2500 */
	en_lls_04	= 25002,	/* LLS04 */
	en_lls_10	= 50001,	/* LLS10 */
	en_lls_15	= 100002,	/* LLS15 */
	en_lls_25	= 100001,	/* LLS25 */
	en_lls_30	= 235002,	/* LLS30 */
	en_lls_50	= 200001,	/* LLS50 */

}	ENG_LPPI;

/* Photohead Z Axis Motor Drive Type */
typedef enum class __en_photohead_z_axis_motor_type__ : UINT8
{
	en_stepper		= 0x01,	/* Stepper Motor */
	en_linear_acs	= 0x02,	/* Linear drive (ACS) */
	en_linear_sm	= 0x03, /* Linear drive (Sieb & Meyer) */

}	ENG_PZMT;

/* Artwork Complexity */
typedef enum class __en_luria_gerber_artwork_complexity__ : UINT8
{
	en_normal							= 0x00,
	en_high								= 0x01,
	en_extreme							= 0x02,

}	ENG_LGAC;

/* TCP command types (CommandType) */
typedef enum class __en_luria_tcp_command_type__ : UINT8
{
	en_write							= 0x10,		// Write something to the LURIA-system
	en_write_reply						= 0x11,		// A reply to a previous Write
	en_read								= 0x20,		// Initiate a read of something from the LURIA-system
	en_read_reply						= 0x21,		// The reply resulting of a previous read
	en_announce							= 0x41,		// Asynchronous announcement from the LURIA-system

}	ENG_LTCT;

/* User Data Family */
typedef enum class __en_luria_user_data_family__ : UINT8
{
	en_none								= 0x00,		/* Not defined */

	en_machine_config					= 0xA0,		/* Defines a set of properties that are used to configure general */
													/* machine based parameters that are normally done once only */
													/* Changing these parameters may require a re-assignment of the job(s) (Read/Write) */
	en_job_management					= 0xA1,		/* Properties and commands that allows a job to be selected */
													/* and loaded, and get some information about the preprocessed job (Read/Write) */
	en_panel_preparation				= 0xA2,		/* Properties and commands that controls the registration and panel data (Read/Write) */
	en_exposure							= 0xA3,		/* Properties and commands that controls the printing of a panel (Read/Write) */
	en_direct_photo_comm				= 0xA4,		/* Allows for communicating with the photo heads themselves, */
													/* using commands (called records) defined in [1] (Read only) */
	en_luria_com_management				= 0xA5,		/* Set up channel for Announcements in LURIA (Read/Write) */
	en_announcement						= 0xA6,		/* Generated by the LURIA. */
	en_system							= 0xA7,		/* Do various system related operations (Read/Write) */
	en_focus							= 0xA8,		/* Control the focus of the photo head(s) (Read/Write) */
	en_calibration						= 0xA9,		/* Functions related to calibration of heads in x, y and z (Read/Write) */
	en_vision							= 0xAA,		/* Table and photohead camera vision commands (Read only) */
	en_toolbox							= 0xAB,		/* Functions for power measurement etc (Write only) */

}	ENG_LUDF;

/* Luria Command - MachineConfig (user_id:0xA0) */
typedef enum class __en_luria_command_machine_config__ : UINT8
{
	en_total_photo_heads				= 0x01,		/* Total number of photoheads in system (1 ~ 8) */
	en_photo_head_ip_addr				= 0x02,		/* The IP Addresses for the photo heads connected to Luria */
	en_photo_head_pitch					= 0x03,		/* Number of strips between two photo heads. Pitch between photoheads, given in number of exposure strips */

	en_lens_magnification_not_used		= 0x04,		/* Lens magnification factor. Lens magnification as a factor, multiplied by 1000. (Eg. factor 0.5 is given as 500) */
													/* Removed (obsolete) from Luria version 2.0.0 and newser */
	en_photo_head_rotate				= 0x05,		/* The alignment of the photo heads. Orientation of photoheads. 0 = No rotation. 1 = Rotated 180 degrees */
	en_parallelogram_motion_adjust		= 0x06,		/* The parallelogram motion angle of the motion controller will be adjusted by this factor. Adjustment factor, multiplied by 1000. (Eg. factor 0.97 is given as 970, factor 1.025 is given as 1025) */
	en_scroll_rate						= 0x07,		/* The maximum scroll rate that a photo head can tolerate. The maximum scroll rate of the system (Default 19000) */
	en_motion_control_type				= 0x08,		/* The motion controller connected to the system. The motion controller type used. 1 = Sieb & Meyer, 2 = Newport */
	en_motion_control_ipaddr			= 0x09,		/* IP address of the motion controller */
	en_x_drive_id_not_used				= 0x0a,		/* The ID to be set for the x-axis in the motion controller. Note! Valid if MotionControlType = 1 only. Ignored for other types */
													/* Removed (obsolete) from Luria version 2.0.0 and newser */
	en_y_drive_id_not_used				= 0x0b,		/* The ID to be set for the y-axis in the motion controller. Up to two y-axis are supported. Note! Valid if MotionControlType = 1 only. Ignored for other types */
													/* Removed (obsolete) from Luria version 2.0.0 and newser */
	en_x_correction_table				= 0x0c,		/* X correction table for the x motion. The first entry must have 0 adjustment. The correction given for the last table entry will be used for x position at higher x positions than the x-position for the last table entry */
	en_table_position_limits			= 0x0d,		/* The minimum and maximum coordinate of the motion controller. This tells the Luria maximum allowable motion position. (Not used yet!) */
	en_table_exposure_start_pos			= 0x0e,		/* The start position for an exposure for the given table */
	en_max_y_motion_speed				= 0x0f,		/* This value limits the maximum speed that the motion controller will run in y-direction */
	en_x_motion_speed					= 0x10,		/* This is the speed to be used for x-movements. This speed will also be used to move to start position during pre-print */
	en_theta_position					= 0x11,		/* Theta drive position for motion controllers having a theta-axis. Note! Valid if MotionControlType = 2 only. Ignored for other types */
	en_y_acceleration					= 0x12,		/* Motion controller Y-axis acceleration. Note! Valid if MotionControlType = 2 only. Ignored for other types */
	en_y_acceleration_distance			= 0x13,		/* Y-axis acceleration/deceleration distance. Note! Valid if MotionControlType = 1 only. Ignored for other types */
	en_hysteresis_type1					= 0x14,		/* Motion controller hysteresis. Note! Valid if MotionControlType = 1 only. Ignored for other types */
	en_hysteresis_type2					= 0x15,		/* Motion controller hysteresis. Note! Valid if MotionControlType = 2 only. Ignored for other types */
	en_photo_head_offset				= 0x16,		/* Measured offset in x- and y directions compared to photo head number 1 */
	en_table_print_direction			= 0x17,		/* Start-direction of y axis when printing */
	en_active_table						= 0x18,		/* Select which table that is the active table. Note! Valid if MotionControlType = 1 only. Ignored for other types */
	en_get_table_motion_start_position	= 0x19,		/* This will give the exact position where the motor will be placed when starting a print. This position will be based on the current TableExposureStartPos and YaccelerationDistance */
	en_emulate_motor_controller			= 0x1a,		/* Enables use of the Luria software without a motion controller */
	en_emulate_photo_heads				= 0x1b,		/* Enables use of the Luria software without photo head(s) */
	en_emulate_triggers					= 0x1c,		/* Enables use of the Luria software without trigger input signals to the photo head(s) */
	en_debug_print						= 0x1d,		/* Prints debug information to logfile */
	en_print_simulation_out_dir			= 0x1e,		/* Output path name text string (without null-termination) of simulation result files. The path must be absolute. Atrailing backslash (\) is optional */
	en_disable_mirror_shake_not_used	= 0x1f,		/* 0 = Mirror shake is enabled (default), 1 = Mirror shake is disabled. Be careful not to disable mirror shake if not strictly needed. Also note that this setting is not stored permanently. At power-up, mirror shake will always be enabled */
													/* Important: Be careful not to disable mirror shake if not strictly needed */
													/* Removed (obsolete) from Luria version 2.0.0 and newser */
	en_y_correction_table				= 0x20,		/* Y-correction table, one for each table. Each printed strip can be adjusted individually, in positive or negative direction. Max y-adjustment is +/- 500 um (500000 nm) */
	en_linear_z_drive_settings			= 0x21,		/* the ID to be set for the z-axis in the motion controller for this specific photo head. Note! Valid if ZdirveType = 2 only */
													/* Valid from Luria version 2.1.0 and newer */
	en_hysteresis_type_3				= 0x22,		/* Motion controller hysteresis for motor controller type 3. Note! Valid if MotionControlType = 3 Only. Ignored for other types */
													/* Valid from Luria version 2.1.0 and newer */
	en_z_drive_ip_addr					= 0x23,		/* IP Address of the Z drive (Focus drive). Note! Valid if ZDriveType = 2 */
													/* Valid from Luria version 2.1.0 and newer */
	en_xy_drive_id						= 0x24,		/* The ID to be set for the x and y-axis in the motion controller for up to two tables. Note! Valid if MotionControlType = 1 and 3 only. Ignored for other types */
	en_product_id						= 0x25,		/* ID identifying the LLS-system */
	en_artwork_complexity				= 0x26,		/* ArtworkComplexity reflects how fine-pitched the artwork is. A complex artwork will result in larger preprocessed files. Selecting a higher ArworkComplexity will allow larger, more complex preprocessed files to be accepted by Luria, by reserving more space inside the photo head(s) storage. */
													/* NOTE: Higher complexity setting will result in fewer jobs to be held simultaneously in Luria. Therefore, ArworkComplexity should be held as low as possible. It should only be increased if loading a preprocessed job results in StatusCode "StripFileSizeTooLarge" */
													/* No longer in use from Luria version 3.0.0 and newer */
	en_z_drive_type						= 0x27,		/* Drive Type: 1 = Stepper motor (built-in), 2 = Linear drive (external) */
													/* Focus Z drive type (1 = Stepper motor (use built in driver in photo heads), 2 = Linear drive (use external driver, such as ACS or similar). This setting is equal for all photo heads */
													/* Valid from Luria version 2.1.0 and newer */
	en_over_pressure_mode				= 0x28,		/* When enabled, this mode will configure the fans so that an over-pressure is created inside the photo head */
													/* Valid from Luria version 2.2.0 and newer */
	en_depth_of_focus					= 0x29,		/* Valid for linear Z-motor only, ignored for stepper motor */
													/* Valid from Luria version 2.6.0 and newer */
	en_extra_long_stripes				= 0x2a,		/* When this is enabled the length of a jobs artwork stripes is approximately twice the length of normal stripes */
													/* Removed from Luria version 3.0.0 and newer (Support for long stripes default, without extra processing time) */
	en_mtc_mode							= 0x2b,		/* Enabling MTC will result in smoother edges in cases where the motion of the y-axis is not perfect. It is required that the job is preprocessed with the MTC mode on. Note that enabling MTC will reduce the maximum scroll rate that can be used. */
													/* Valid from Luria version 3.0.0 and newer */
	en_use_ethercat_for_af				= 0x2c,		/* When not using ethercat for AF Luria will not try to communicate over ethercat with the z-motion controller */
													/* Valid from Luria version 2.12.0 and newer */
	en_spx_level						= 0x2d,		/* The spx-level from preprocessed files must correspond to the value set here */
													/* Valid from Luria version 3.0.0 and newer */
	en_ocp_error_mask					= 0x2e,		/* This will mask any OCP errors for the time that is given. This will apply to ALL light sources */
													/* Valid from Luria version 2.12.2 and 3.1.0, and newer */
	en_position_hysteresis_type1		= 0x2f,		/* Motion controller hysteresis. Note! Valid if MotionControlType = 1 only. Ignored for other types This hysteresis is position based, and will not be affected by the print speed. Note: This hysteresis is added to the hysteresis done by HysteresisType1 */
													/* Valid from Luria version 2.13.0 and 3.2.0, and newer */
	en_custom_edge_blend_bitmap			= 0x30,		/* Path and filename (without null termination) of custom edge lend bitmap. The given bitmap file must exist on the Luria-PC disc and must have the format of 8 x 1600 pixels for 9k5-based products and 8 x 1080 for 4k8 products */
													/* The left half of the bitmap is the left bitmap (4 pixels wide) and the right half is the right bitmap (4 pixels wide). The bitmap must be in 1-bit monochrome format. Limit: L < 200 */
													/* If the built-in default butilt-in bitmap is to be used, an empty string with L=0 must be used */
													/* Valid from Luria version 3.2.0 and newer */
}	ENG_LCMC;

/* Job Management command (user_id : 0xA1) */
typedef enum class __en_luria_command_job_management__ : UINT8
{
	en_root_directory					= 0x01,		/* Root directory where pre-processed jobs are placed. Note: There must be no assigned jobs when changing RootDirectory. */
													/* If trying to change RootDirectory while jobs are assigned, an error will be returned. The RootDirectory given must exist unless giving an empty string (L = 0), which will clear the root directory. */
	en_get_job_list						= 0x02,		/* If no jobs are assigned, then nothing is returned, L = 0. The paths may be a mix of relative and absolute paths, depending on how the jobs were assigned. */
	en_assign_job						= 0x03,		/* Path name text string (without null-termination) of a preprocessed job. Could be relative path (relative to RootDirectory) or absolute path. A trailing backslash (\) is optional. */
													/* Assign a new job. The path name given is the path to valid pre-processed job. An error message will be given if the path does not contain valid files. */
													/* The first assigned job will be set as selected job automatically. */
	en_delete_selected_job				= 0x04,		/* Delete the selected job from the list of assigned jobs. If no jobs assigned, an error will be returned. (This command will not delete anything from the disk, only from the list of assigned jobs). */
	en_selected_job						= 0x05,		/* Path name text string (without null-termination) of selected job. The path may be relative or absolute. A trailing backslash (\) is optional. */
	en_load_selected_job				= 0x06,		/* Load the currently selected job to the photo head(s). */
													/* reply is returned immediately and the load progress can be queried using "GetSelectedJobLoadState". */
													/* Alternatively, announcements from the Luria can be used uria will send "LoadState"-announcements after each strip being loaded to a photo head and also when all files are loaded completely (or if any failure happened). */
	en_get_selected_job_load_state		= 0x07,		/* Returns the current load-state of the system (0x01-Load not started, 0x02 - Loading, 0x03-Load complete, 0x0f-Load failed) */
	en_get_fiducials					= 0x08,		/* Returns the global and local fiducial points of the given job. */
	en_get_parameters					= 0x09,		/* Returns a set of parameters for the given job */
	en_get_panel_data_dcode_list		= 0x0a,		/* Returns all defined dynamic panel data dcodes for the given job. */
	en_get_panel_data_info				= 0x0b,		/* Returns all the panel data information for the given d-code and job. */
	en_get_max_jobs						= 0x0c,		/* The maximum number of jobs that can be assigned simultaneously */
													/* The number of jobs than can be assigned simultaneously will vary according to photo head hardware and MachineConfig: ArtworkComplexity setting */

}	ENG_LCJM;

/* Panel Preparation command (user_id : 0xA2) */
typedef enum class __en_luria_command_panel_preparation__ : UINT8
{
	en_dynamic_fiducials				= 0x01,		/* Dynamic fiducial coordinates. When sending dynamic fiducials these will be used instead of global and local fiducials from the gerber-file. */
													/* Up to 8 (N<= 8) global dynamic fiducials, while up to 200 (N <= 200) local dynamic fiducials are supported. */
													/* NOTE: To enable use of global and local fiducials from gerber-file again, then a special DynamicFiducials command where type = 0 (global) and N = 0 must be sent. */
	en_registration_points				= 0x02,		/* Registration points. Up to 400 registration points are supported, ie. N <= 400. */
	en_global_transformation_receipe	= 0x03,		/* Transformation recipe that is valid for both global and local zones. If set to Fixed, the values in FixedRotation, FixedScaling and FixedOffset are used. */
	en_global_fixed_rotation			= 0x04,		/* Global fixed rotation, in micro-degrees. Ignored for TransformationReceipe 0. */
	en_global_fixed_scaling				= 0x05,		/* Global fixed x and y-scaling factor * 106 . Ignored for TransformationReceipe 0. */
	en_global_fixed_offset				= 0x06,		/* Global fixed x and y-offset. In nanometers. Ignored for TransformationReceipe 0. */
	en_local_zone_geometry				= 0x07,		/* This will determine the zone geometry to be used for local zones. */
	en_get_number_of_local_zones		= 0x08,		/* The number of calculated local zones. */
	en_get_transformation_params		= 0x09,		/* Retrieve the transformation parameters based on the current registration points and transformation recipe. */
	en_unused							= 0x0a,
	en_run_registration					= 0x0b,		/* Will run registration based on the current fiducials and registration points. */
													/* If registration error is received, then the detailed error can be found using */
													/* "GetRegistrationStatus" command. (Note that this command is also run automatically during PrePrint) */
	en_get_registration_status			= 0x0c,		/* Retrieve the current status of the registration module in Luria */
	en_panel_data_serial_number			= 0x0d,		/* Set the serial number string and number to be incremented per board. */
													/* If the serial number string is set to ABCD####WXYZ, the symbol marking increment number is '#' and starting value is set to 0123, */
													/* then the first serial number will be printed as ABCD0123WXYZ, the next ABCD0124WXYZ and */
													/* so on for all the D-codes defined as SerialNumber. If the number reaches max value, e.g. 999, the next value will be 000. */
	en_panel_data						= 0x0e,		/* Specify the panel data to be printed on the panel, where to print it and the size/orientation. */
													/* D-code must match what is specified in the job (from PreProcessing), where also the PanelData type is pre-defined. */
													/* For SerialNumber and Scaling information, the Length of string should be set to 0 and Text string (S) should be ignored, */
													/* but for GeneralText this is the text string that will be printed. */
	en_use_shared_local_zones			= 0x0f,		/* If “Use shared zones” is selected, then the system will try to create shared zones where possible */
	en_local_transformation_recipe		= 0x10,		/* Transformation recipe that is valid for local zones. If set to Fixed, the values in LocalFixedRotation, LocalFixedScaling and LocalFixedOffset are used. */
	en_local_fixed_rotation				= 0x11,		/* Has effect in fixed transformation mode only. Fixed rotation to be used. N <= 200. */
	en_local_fixed_scaling				= 0x12,		/* Has effect in fixed transformation mode only. Fixed scaling to be used. N <= 200. (Eg. Factor 1.0002 is given as 1000200, factor 0.9998 is given as 999800) */
	en_local_fixed_offset				= 0x13,		/* Has effect in fixed transformation mode only. Fixed offset to be used. N <= 200. */
	en_global_rectangle_lock			= 0x14,		/* When global auto transformation recipe is selected, it is possible to force the registration points to make a rectangle. */
	en_remove_panel_data				= 0x15,		/* Will remove the panel data that is assigned to the given d-code */
	en_get_warp_of_limits_coordinates	= 0x16,		/* Get coordinates where registration result in warp out of fpga limits. Max reported errors is 400. In this case the whole panel may be out of war limits and thus print should not be proceeded */
	en_snap_to_zone_mode				= 0x17,		/* When this mode is enabled, the artwork is always warped to the closest zone registration setting */
													/* This mode can only be used in combination with non-shared local zones. And the zones have to be distributed in a grid parallel to x and y axis (not scattered). Recommended to use only one zone in y direction. */
	en_local_zone_fid_search_bw			= 0x18,		/* Set the band width for searching fiducials in a zone. Nominal values are typically below 1mm to allow strictly rectangular zones only. This interface may be used to increase the search limit to allow for non square zones. Values should be set as low as possible to avoid risk of confusing fiducials between zones. */

}	ENG_LCPP;

/* Exposure Command (user_id : 0xA3) */
typedef enum class __en_luria_command_exposure_printing__ : UINT8
{
	en_light_amplitude					= 0x01,		/* Set the LED amplitude that will be used for the exposure */
													/* Luria will set the given amplitude in the photo head(s) when printing starts */
	en_scroll_step_size					= 0x02,		/* Set the scroll step size to be used for the exposure. */
	en_frame_rate_factor				= 0x03,		/* Set the frame rate factor to be used for the exposure. */
													/* The factor will reduce the exposure speed by the given factor. */
													/* Exp. factor 0,5 (given as 500) will reduce the speed to half. */
	en_led_duty_cycle					= 0x04,		/* Set the desired duty cycle of the LEDs in the photo head. */
													/* Luria will set the LED on-time in all LEDs when starting an exposure. LED on-time = (1 / (ScrollRate * ScrollStepSize * FrameRateFactor)) * LedDutyCycle/100 */
	en_pre_print						= 0x05,		/* Prepare for a new print. This will make "Print" starting immediately when is called later. */
													/* This command can be run in "shadow" time. Note that this will move the system to its exposure starting position. */
													/* The current settings (led amplitude, scroll step size, duty cycle, etc) are set in the photo heads at this time. */
													/* NOTE: This command always returns OK immediately. Any errors occurring during pre-print process is sent as an asynchronous announcement error. */
	en_print							= 0x06,		/* Start a print of the currently selected job. Requires PrePrint to be run in advance. Status during printing can be queried using GetExposureState or by reading incoming announcements. */
													/* NOTE: This command always returns OK immediately. Any errors occurring during print process is sent as an asynchronous announcement error. */
	en_abort							= 0x07,		/* Abort the current action. Note that it may take some time until the abort-operation is completed. This can be checked using GetExposureState, see Table 1 below. */
	en_get_exposure_state				= 0x08,		/* Get the current exposure state. If state is "PrintRunning", then information about the current motion is given. */
	en_get_exposure_speed				= 0x09,		/* the motion speed that will be used (or that is being used if printing). */
													/* This speed is calculated as follows: speed (meter/sec) = ScrollRate * PixelSize * ScrollStepSize * FrameRateFactor. Note: speed <= MaxMotionSpeed */
	en_reset_exposure_state				= 0x0a,		/* Reset the exposure state for the currently selected job irrespective of current state */
	en_enable_af_copy_last_strip		= 0x0b,		/* Enable AF copy function. 0 = Disable (default), 1 = Enable. */
													/* When function is enabled, the photo head printing the last strip will copy the autofocus profile of the second to last strip and IMPLEMENTED */
													/* use that profile for focusing the last strip. If autofocus is disabled in the photo head, then this function is bypassed. */
	en_simulate_print					= 0x0c,		/* Start a simulated print. The selected job will be printed to a file instead of exposed through the photo head(s). The resulting */
													/* output image will be written to the output directory given in MachineConfig::PrintSimulationOutDir */
	en_move_table_to_exposure_start_pos	= 0x0d,		/* This will move the active table to its exposure start position. */
	en_get_number_of_light_sources		= 0x0e,		/* Get the number of available light sources for the given photo head. */
	en_get_light_source_status			= 0x0f,		/* Get the status of the requested light source (en_light_source_status_multi로 대체) */
	en_disable_af_first_strip			= 0x10,		/* This command makes it possible to turn off autofocus for the first strip of a print, for example if this strip is outside the panel. if autofocus is disabled in the photo head, then this function is bypassed */
	en_af_sensor						= 0x11,		/* The selected AF sensor type and laser setting are set in the phot head(s) when running PrePrint. Note that these seetings only apply if autofocus is used */
	en_light_ramp_up_down				= 0x12,		/* This command should be sent to Luria if the current light amplitude is significantly higer / lower than the amplitude used in the previsou print. */
													/* Important: This command must be sent after sending LightAmplitude command but before PrePrint */
													/* Note that this command is not valid for RLT systems, If sending this command when RLT heads are connected, then an error message will be given. */
	en_af_sensor_measure_laser_pwm		= 0x13,		/* Function returns optimal laser PWM by using AGC function. The measured values are saved in Luria for current Job. When new job are loaded new measurements have to be take. */
	en_light_source_status_multi		= 0x14,		/* Get the light source type and status of all light sources in all photo heads. See table below for detailed information on the status word */

}	ENG_LCEP;

/* Direct Photohead (user_id : 0xA4) */
typedef enum class __en_luria_command_direct_photohead__ : UINT8
{
	en_photohead_command				= 0x01,		/* Photohead Command (Read Only) */

}	ENG_LCDP;

/* LuxBeam 4600 ~ 4700 or 4800 Software Interface - Record Number */
typedef enum class __en_lurai_luxbeam_record_number__ : UINT16
{
	en_none									= 0x0000,
	/* ---------------------------------------- */
	/*  General Reply Record                    */
	/* ---------------------------------------- */
	/* 21.01.01 : Reply Ack */
	en_res_reply_ack						= 0x01F5,	/* 501 : Reply */

	/* 21.02.01 : Inum Size (Not developed) */
	en_set_inum_size						= 0x0066,	/* 102 : SET */
	en_get_inum_size						= 0x012E,	/* 302 : GET */
	en_res_inum_size						= 0x01F6,	/* 502 : RES */
	/* 21.02.02 : Image Type (Not developed) */
	en_set_image_type						= 0x0067,	/* 103 : SET */
	en_get_image_type						= 0x012F,	/* 303 : GET */
	en_res_image_type						= 0x01F7,	/* 503 : RES */
	/* 21.02.03 : Load Image Data (Not developed) */
	en_set_load_image_data					= 0x0068,	/* 104 : SET */
	/* 21.03.01 : Load Sequence File Text (Not developed) */
	en_set_load_sequence_file_text			= 0x0069,	/* 105 : SET */
	/* 21.03.03 : Sequencer State */
	en_set_sequencer_state					= 0x006A,	/* 106 : SET */
	en_get_sequencer_state					= 0x0132,	/* 306 : SET */
	en_res_sequencer_state					= 0x01FA,	/* 506 : SET */
	/* 21.03.04 : Sequencer File Error Log (Not developed) */
	en_get_sequencer_file_error_log			= 0x0133,	/* 307 : SET */
	en_res_sequencer_file_error_log			= 0x01FB,	/* 507 : SET */
	/* 21.02.10 Load Flatness Correction Mask (PPC) (Not developed) */
	en_set_load_flatness_correction_mask= 0x0074,	/* 116 : SET */
	/* Line Sensor Plot */
	en_set_plot_enable						= 0x0076,	/* 118 : SET */
	en_get_plot_enable						= 0x013E,	/* 318 : GET */
	en_res_plot_enable						= 0x0206,	/* 518 : RES */
	/* 21.03.05 Software Sync */
	en_set_software_sync					= 0x0078,	/* 120 : SET */
	en_get_software_sync					= 0x0140,	/* 320 : GET */
	en_res_software_sync					= 0x0208,	/* 520 : RES */
	/* 21.03.07 Sequencer Register (Not developed) */
	en_set_sequencer_register				= 0x007A,	/* 122 : SET */
	en_get_sequencer_register				= 0x0142,	/* 322 : GET */
	en_res_sequencer_register				= 0x020A,	/* 522 : RES */
	/* 21.03.08 Light Pulse Duration (Not developed) */
	en_set_light_pulse_duration				= 0x007B,	/* 123 : SET */
	en_get_light_pulse_duration				= 0x0143,	/* 323 : GET */
	en_res_light_pulse_duration				= 0x020B,	/* 523 : RES */
	/* Motor Position Initialize */
	en_set_fcs_mtr_mid_pos					= 0x007D,	/* 125 : SET */
	/* Focus Motor Calibration - Measured Distance */
	en_set_fcs_mtr_measure_dist				= 0x007E,	/* 126 : SET */
	en_get_fcs_mtr_measure_dist				= 0x0146,	/* 326 : GET */
	en_res_fcs_mtr_measure_dist				= 0x020E,	/* 526 : RES */
	/* Focus Motor Status */	
	en_get_fcs_motor_status					= 0x0148,	/* 328 : GET */
	en_res_fcs_motor_status					= 0x0210,	/* 528 : RES */
	/* Focus Motor Move Absolute Position */
	en_set_fcs_mtr_abs_pos					= 0x0084,	/* 132 : SET */
	en_get_fcs_mtr_abs_pos					= 0x014C,	/* 332 : GET */
	en_res_fcs_mtr_abs_pos					= 0x0214,	/* 532 : RES */
	/* LED Driver Amplitude */
	en_set_led_amplitude					= 0x0085,	/* 133 : SET */
	en_get_led_amplitude					= 0x014D,	/* 333 : GET */
	en_res_led_amplitude					= 0x0215,	/* 533 : RES */
	/* Light Source Driver Status */
	en_get_led_drive_status					= 0x014E,	/* 334 : GET */
	en_res_led_drive_status					= 0x0216,	/* 534 : RES */
	/* Photohead LED Temperature */
	en_get_ph_led_temp						= 0x014F,	/* 335 : GET */
	en_res_ph_led_temp						= 0x0217,	/* 535 : RES */
	/* LED Driver Light On / Off */
	en_set_led_light_on_off					= 0x0089,	/* 137 : SET */
	en_get_led_light_on_off					= 0x0151,	/* 337 : GET */
	en_res_led_light_on_off					= 0x0219,	/* 537 : RES */
	/* 03.06 Current Autofocus Position (Not developed) */
	en_set_internal_sync_frequency			= 0x0090,	/* 144 : SET */
	en_get_internal_sync_frequency			= 0x0158,	/* 344 : GET */
	en_res_internal_sync_frequency			= 0x0220,	/* 544 : RES */
	/* Current Autofocus Position */
	en_get_autofocus_position				= 0x0159,	/* 345 : GET */
	en_res_autofocus_position				= 0x0221,	/* 545 : RES */
	/* 21.02.11 Enable Flatness Correction Mask (PPC) */
	en_set_enable_flatness_correction_mask	= 0x0094,	/* 148 : SET */
	en_get_enable_flatness_correction_mask	= 0x015C,	/* 348 : GET */
	en_res_enable_flatness_correction_mask	= 0x0224,	/* 548 : RES */
	/* 21.03.09 Trigger Info (Not developed) */
	en_get_trigger_info						= 0x0160,	/* 352 : GET */
	en_res_trigger_info						= 0x0228,	/* 552 : RES */
	/* Photohead LED On-Time */
	en_get_ph_led_ontime					= 0x016A,	/* 362 : GET */
	en_res_ph_led_ontime					= 0x0232,	/* 562 : RES */
	/* 02.12 Load Internal Image */
	en_set_load_internal_image				= 0x00A9,	/* 169 : SET */
	en_get_load_internal_image				= 0x0171,	/* 369 : GET */
	en_res_load_internal_image				= 0x0239,	/* 569 : RES */
	/* 21.02.13 Save Internal Image (Not developed) */
	en_set_save_internal_image				= 0x00AA,	/* 170 : SET */
	/* Active Sequence File */
	en_set_active_sequence					= 0x00AB,	/* 171 : SET */
	en_get_active_sequence					= 0x0173,	/* 371 : GET */
	en_res_active_sequence					= 0x023B,	/* 571 : RES */
	/* Clear Error Status */
	en_set_clear_error_status				= 0x00AE,	/* 174 : SET */
	/* Overall Error Status Word */
	en_get_overall_error_status				= 0x0178,	/* 376 : GET */
	en_res_overall_error_status				= 0x0240,	/* 576 : RES */
	/* 02.09 Read Strip Image Data (Not developed) */
	en_get_read_strip_image_data			= 0x017B,	/* 379 : GET */
	en_res_read_strip_image_data			= 0x0243,	/* 579 : RES */
	/* 21.02.14 Scaling Matrix (Not developed) */
	en_set_scaling_matrix					= 0x00B8,	/* 184 : SET */
	/* 21.02.07 Lines Ready to Print (Not developed) */
	en_get_lines_ready_to_print				= 0x0181,	/* 385 : GET */
	en_res_lines_ready_to_print				= 0x0249,	/* 585 : RES */
	/* 21.02.15 Blend Size (Obsolete - not to used) */
	en_set_blend_size						= 0x00C0,	/* 192 : SET */
	/* 21.02.16 Set Strip overlap Info (Not developed) */
	en_set_strip_overlap_info				= 0x00B9,	/* 193 : SET */
	/* 21.02.06 Host-buffer Configuration */
	en_set_host_buff_config					= 0x00C2,	/* 194 : SET */
	/* 22.02.11 DMD Mirror Shake */
	en_set_dmd_mirror_shake					= 0x00C3,	/* 195 : SET */
	en_get_dmd_mirror_shake					= 0x018B,	/* 395 : GET */
	en_res_dmd_mirror_shake					= 0x0253,	/* 595 : RES */
	/* Camera Illumination LED */
	en_set_illum_led						= 0x00C4,	/* 196 : SET */
	en_get_illum_led						= 0x018C,	/* 396 : GET */
	en_res_illum_led						= 0x0254,	/* 596 : RES */
	/* 03.02 : Load Sequence File Binary (Not developed) */
	en_set_load_sequence_file_bin			= 0x00C6,	/* 198 : SET */
	/* Light Source Info */
	en_get_light_source_info				= 0x01A5,	/* 421 : GET */
	en_res_light_source_info				= 0x026D,	/* 621 : RES */
	/* 02.18 DMD Flip */
	en_set_dmd_flip_output					= 0x00E9,	/* 233 : SET */
	en_get_dmd_flip_output					= 0x01B1,	/* 433 : GET */
	en_res_dmd_flip_output					= 0x0279,	/* 633 : RES */
	/* 02.17 Set Strip Blending (Not developed) */
	en_set_strip_blending					= 0x00F1,	/* 241 : SET */
	/* 02.04 : Streamed File (Not developed) */
	en_set_streamed_file					= 0x00F6,	/* 246 : SET */
	/* 02.05 : Streamed Print Strip (Not developed) */
	en_set_streamed_print_strip				= 0x00F7,	/* 247 : SET */
	/* 02.08 : CRC Indicator (Not developed) */
	en_set_crc_indicator					= 0x00F8,	/* 248 : SET */
	en_get_crc_indicator					= 0x01C0,	/* 448 : GET */
	en_res_crc_indicator					= 0x0288,	/* 648 : RES */
	/* 02.19 : Flush Row Limit (Not developed) */
	en_set_flush_row_limit					= 0x00F9,	/* 249 : SET */
	en_get_flush_row_limit					= 0x01C1,	/* 449 : GET */
	en_res_flush_row_limit					= 0x0289,	/* 649 : RES */

}	ENG_LLRN;

/* Com Management Command (user_id : 0xA5) */
typedef enum class __en_luria_command_com_management__ : UINT8
{
	en_announce_server_ipaddr			= 0x01,		/* The IP address of the UI (announce server) that the Luria (announce client) will send announcements to. */
													/* The default IP address at Luria power-on is 0.0.0.0. Luria will send announcements only if the IP address is different from 0.0.0.0. */
													/* Hence, if UI do not want the Luria to generate announcements, the IP address should be set to 0.0.0.0. */
	en_test_announcement				= 0x02,		/* Force a "TestAnnouncement" to be sent from Luria. */
													/* This will be sent if AnnounceServerIpAddr is different from 0.0.0.0. */
													/* If the "TestAnnouncement" was unsuccessfully sent for the third time in a row (i.e. the reply to "GenerateTestAnnouncement" was not OK three times), */
													/* all announcements will be disabled, irrespective of AnnounceServerIpAddr not being 0.0.0.0. */
													/* The announcements will be enabled again as soon as a "TestAnnouncement" was successfully sent (i.e. if"GenerateTestAnnouncement" is ok) */
	en_announcement_status				= 0x03,		/* The announcements will be automatically disabled by Luria if no announcements could be sent three times in a row. */
													/* The only way it will be enabled again is by successfully sending a "GenerateTestAnnouncement". */
													/* Note that the status will be "disabled" if AnnounceServerIpAddr is 0.0.0.0. */
}	ENG_LCCM;

/* Announcement Command (user_id : 0xA6) */
typedef enum class __en_luria_command_event_announcement__ : UINT8
{
	en_test_announcement				= 0x01,		/* Sent only when requested by peer (UI), using LuriaComManagement -> "GenerateTestAnnouncement" */
	en_error							= 0x02,		/* This announcement is sent if an error occurs asynchronously. */
													/* The "Status"-field holds an error number, indicating the specific error. */
	en_load_state						= 0x03,		/* This announcement is sent every time a strip has been loaded to a photo head and when a complete gerber has been loaded successfully (or when loading fails). */
	en_exposure_state					= 0x04,		/* This announcement is sent every time a print motion is complete and when a print/pre-print is completed successfully (or with failure). */

}	ENG_LCEA;

/* System status command (user_id : 0xA7) */
typedef enum class __en_luria_command_system_status__ : UINT8
{
	en_initialize_hardware				= 0x01,		/* This command will try to connect to all external devices (photo heads, motion controller, etc) and initialize these */
													/* This command must be called before being able to print */
	en_get_system_status				= 0x02,		/* Query the status of the complete system (Read Only) */
	en_set_system_shutdown				= 0x03,		/* This command will safely shut down all components of the system. (Write Only) */
	en_set_dummy_cmd					= 0x04,		/* No action is taken for this command. Luria will ignore it and send no reply. For test-purposes only */
	en_upgrade_firmware					= 0x05,		/* This command will upgrade all photo heads with the firmware in the given bundle path or firmware file. The path name can be an absolute path to a LLS software bundle or a path to a tar.gz file to be used for upgrading. When the upgrade starts, a new initializeHardware will be required. If trying to do initializeHardware before upgrade process is complete, BusyUpgradingFirmware status code is given. */
	en_get_smart_data					= 0x06,		/* This command will read out the SMART data on the SSD. The SMART data consists of 14 sources with each 12 parameters */
	en_load_internal_test_image			= 0x07,		/* This will load the selected test image that is built-in the photo head and display it on the DMD */
	en_set_light_intensity				= 0x08,		/* Use this command to turn on the light in the photo head(s) in order to display the internal test image selected using command LoadInternalTestImage */
	en_mainboard_temperature			= 0x09,		/* This will give the temperature of the mainboard for each photo head */
	en_overall_error_status_multi		= 0x0a,		/* Get the error status for all photo heads. See table below for bit definitions of the error status word */

}	ENG_LCSS;

/* Photohead Focus command (user_id : 0xA8) */
typedef enum class __en_luria_command_photohead_focus__ : UINT8
{
	en_initialize_focus					= 0x01,		/* This will initialize the z-axis. Note that this may take up to 30 seconds to complete. If initialize failes, the status code FocusMotorOperationFailed is give */
	en_position							= 0x02,		/* Focus Z-position given in micrometers. */
	en_auto_focus						= 0x03,		/* Start / Stop (Enable / Disable) photo head auto focus system */
	en_trim								= 0x04,		/* Focus trim in nanometers */
	en_active_area_qualifier			= 0x05,		/* Autofocus will only operate inside the limits given here */
	en_abs_work_range					= 0x06,		/* Note that setting AbsWOrkRange will clear the AbsWorkRangeStatus for the given photo heads(s) */
	en_abs_work_range_status			= 0x07,		/* The status-bit for a given photo head will be cleared next time a new AbsWorkRange has been set. */
	en_af_edge_trigger					= 0x08,		/* If the next focus point is further below or above the current focus point than the given value, then the focus will not be changed */
	en_set_position_multi				= 0x09,		/* Set focus position for several photo heads simulatneously. */
	en_position_hi_res					= 0x0a,		/* Set or get current focus position of a single head. Note that this command is duplicating Focus:Position command, but with higher resolution */
	en_outside_dof_status				= 0x0b,		/* Reports the number of trigger pulses that autofocus position has been outside the given DOF (MachineConfig:DepthOfFocus) */
	en_get_position_multi				= 0x0c,		/* Get focus position for all photo heads simulaneously */
	en_af_gain							= 0x0d,		/* This will set the autofocus gain (damping factor) in the photo heads. The default gain value is 10. */
	en_scan_ethercat					= 0x0e,		/* This will start a scan for ethercat devices when using linear z-axis from Sieb&Meyer */

	en_af_panelmode	= 0x11,
	en_af_disablefocus = 0x12,

}	ENG_LCPF;

/* Photohead Motor Status */
typedef enum class __en_luria_photohead_motor_status__ : UINT16
{
	en_busy_moving						= 0x0000,
	en_must_move_to_mid_pos				= 0x0001,
	en_endpt_reached					= 0x0002,
	en_mid_pos_proc_running				= 0x0004,
	en_mid_pos_proc_ep_low_reached		= 0x0008,
	en_mid_pos_proc_ep_upp_reached		= 0x0010,
	en_timeout_mid_pos_process			= 0x0020,
	en_af_outcast_detected				= 0x0040,
	en_af_sensor_signal_missing			= 0x0080,
	en_af_position_outside_work_range	= 0x0100,
	en_controller_connected				= 0x0200,
	en_mid_pos_proc_aborted				= 0x0400,

}	ENG_LPMS;

/* Job Management - SelectedJobLoadState */
typedef enum class __en_selected_job_load_state__ : UINT8
{
	en_load_not_started					= 0x01,
	en_loading							= 0x02,
	en_load_complete					= 0x03,
	en_load_failed						= 0x0f,

}	ENG_SJLS;

/* Job Management - Panel Data Type */
typedef enum class __en_panel_data_type_code__ : UINT8
{
	en_text								= 0x00,	/* Text */
	en_qr_code							= 0x01,	/* QR Code */
	en_ecc_200							= 0x02,	/* ECC 200 */

}	ENG_PDTC;

/* Job Management - Panel Data Content */
typedef enum class __en_panel_data_content_code__ : UINT8
{
	en_serial							= 0x00,	/* Board Serial Number */
	en_scale							= 0x01,	/* Scaling Information */
	en_text								= 0x02,	/* General Text */

}	ENG_PDCC;

/* Align Mark Type Flag */
typedef enum class __en_align_mark_type_flag__ : UINT8
{
	en_none								= 0x00,
	en_global							= 0x01,
	en_local							= 0x02,	/* 분할 노광 방식에서 혼합된 Mark (Global & Local)*/
	en_mixed							= 0x03,	/* Global + Local 혼합 의미. (개수 구할 때 필요) */

}	ENG_AMTF;

/* Job Management - Get Registration Status */
typedef enum class __en_panel_data_registration_status__ : UINT8
{
	en_ok													= 1,
	en_missing_fiducials									= 2,
	en_missing_registration									= 3,
	en_generate_not_run										= 4,
	en_strip_height_not_set									= 5,
	en_strip_width_not_set									= 6,
	en_number_of_stripes_not_set							= 7,
	en_overlap_not_set										= 8,
	en_scaling_point_distance_not_set						= 9,
	en_corner_shifts_outside_limits							= 10,
	en_number_of_reg_and_fid_not_equal						= 11,
	en_unable_to_interpret_fiducials						= 12,
	en_unable_to_interpret_registrations					= 13,
	en_invalid_number_of_scaling_points						= 14,
	en_number_of_stripes_matrix_size_mismatch				= 15,
	en_missing_offsets										= 16,
	en_missing_strip_flip_list								= 17,
	en_missing_xbase_step_size								= 18,
	en_rotation_outside_limits								= 19,
	en_scaling_outside_limits								= 20,
	en_offset_outside_limits								= 21,
	en_number_of_fixed_paramin_correct						= 22,
	en_calc_rotation_out_of_limits							= 23,
	en_calc_scale_out_of_limits								= 24,
	en_calc_offset_out_of_limits							= 25,
	en_fixed_rotation_param_out_of_limits					= 26,
	en_fixed_scale_param_out_of_limits						= 27,
	en_fixed_offset_paramo_ut_of_limits						= 28,
	en_warp_outside_limits_in_zone							= 29,
	en_warp_outside_limits_outside_zone						= 30,
	en_warp_unable_to_calculate_warp_zone					= 31,
	en_warp_undefined_local_zones_fixed_param_not_allowed	= 32,
	en_warp_fixed_param_not_allowed_with_shared_zones		= 33,
	en_warp_outside_fpga_limits								= 34,
	en_internal_error										= 99,

}	ENG_PDRS;

/* Coordinate Type Code */
typedef enum class __en_panel_data_coord_type__ : UINT8
{
	en_dynamic_fiducial_global			= 0x00,
	en_dynamic_fiducial_local			= 0x01,
	en_registration_point				= 0x02,

}	ENG_PDCT;

/* 주요 데이터 처리 방법 플래그 */
typedef enum class __en_flag_data_packet_recv__ : UINT16
{
	/* Luria - Machine Config */
	en_mc_total_photo_heads					= 0xA001,
	en_mc_photo_head_ip_addr				= 0xA002,
	en_mc_photo_head_pitch					= 0xA003,
	en_mc_photo_head_rotate					= 0xA005,
	en_mc_parallel_ogram_motion_adjust		= 0xA006,
	en_mc_scroll_rate						= 0xA007,	
	en_mc_motion_control_type				= 0xA008,	
	en_mc_motion_control_ipaddr				= 0xA009,
	en_mc_x_correction_table				= 0xA00C,
	en_mc_table_position_limits				= 0xA00D,
	en_mc_table_exposure_start_pos			= 0xA00E,
	en_mc_max_y_motion_speed				= 0xA00F,
	en_mc_x_motion_speed					= 0xA010,
	en_mc_theta_position					= 0xA011,
	en_mc_y_acceleration					= 0xA012,
	en_mc_y_acceleration_distance			= 0xA013,	
	en_mc_hysteresis_type1					= 0xA014,
	en_mc_hysteresis_type2					= 0xA015,
	en_mc_photo_head_offset					= 0xA016,
	en_mc_table_print_direction				= 0xA017,
	en_mc_active_table						= 0xA018,
	en_mc_get_table_motion_start_position	= 0xA019,	
	en_mc_emulate_motor_controller			= 0xA01A,
	en_mc_emulate_photo_heads				= 0xA01B,	
	en_mc_emulate_triggers					= 0xA01C,
	en_mc_debug_print						= 0xA01D,	
	en_mc_print_simulation_out_dir			= 0xA01E,
	en_mc_y_correction_table				= 0xA020,
	en_mc_linear_z_drive_settings			= 0xA021,	
	en_mc_hysteresis_type_3					= 0xA022,
	en_mc_z_drive_ip_addr					= 0xA023,	
	en_mc_xy_drive_id						= 0xA024,	
	en_mc_product_id						= 0xA025,
	en_mc_artwork_complexity				= 0xA026,
	en_mc_z_drive_type						= 0xA027,
	en_mc_over_pressure_mode				= 0xA028,
	en_mc_depth_of_focus					= 0xA029,
	en_mc_extra_long_stripes				= 0xA02a,
	en_mc_mtc_mode							= 0xA02b,
	en_mc_use_ethercat_for_af				= 0xA02c,
	en_mc_spx_level							= 0xA02d,

	/* Luria - Job Management */
	en_root_directory						= 0xA101,
	en_get_job_list							= 0xA102,
	en_selected_job							= 0xA105,
	en_get_selected_job_load_state			= 0xA107,
	en_get_fiducials						= 0xA108,
	en_get_parameters						= 0xA109,
	en_get_panel_data_dcode_list			= 0xA10A,
	en_get_panel_data_info					= 0xA10B,
	en_get_max_jobs							= 0xA10C,

	/* Luria - Panel Preparation */
	en_dynamic_fiducials					= 0xA201,
	en_registration_points					= 0xA202,
	en_global_transformation_receipe		= 0xA203,
	en_global_fixed_rotation				= 0xA204,
	en_global_fixed_scaling					= 0xA205,
	en_global_fixed_offset					= 0xA206,
	en_local_zone_geometry					= 0xA207,
	en_get_number_of_local_zones			= 0xA208,
	en_get_transformation_params			= 0xA209,
	en_get_registration_status				= 0xA20C,
	en_panel_data_serial_number				= 0xA20D,
	en_panel_data							= 0xA20E,
	en_use_shared_local_zones				= 0xA20F,
	en_local_transformation_recipe			= 0xA210,
	en_local_fixed_rotation					= 0xA211,
	en_local_fixed_scaling					= 0xA212,
	en_local_fixed_offset					= 0xA213,
	en_global_rectangle_lock				= 0xA214,
	en_get_warp_of_limits_coordinates		= 0xA216,

	/* Luria - Exposure */
	en_led_amplitude						= 0xA301,
	en_scroll_step_size						= 0xA302,
	en_frame_rate_factor					= 0xA303,
	en_led_duty_cycle						= 0xA304,
	en_get_exposure_state					= 0xA308,
	en_get_exposure_speed					= 0xA309,
	en_enable_af_copy_last_strip			= 0xA30B,
	en_get_number_of_light_sources			= 0xA30E,
	en_get_light_source_status				= 0xA30F,
	en_disable_af_first_strip				= 0xA310,
	en_af_sensor							= 0xA311,
	en_af_sensor_measure_laser_pwm			= 0xA313,

	/* Luria - Direct Photohead */
	en_luria_direct_ph						= 0xA401,

	/* Luria - System Config */
	en_get_system_status					= 0xA701,
	en_set_dummy_cmd						= 0xA704,
	en_get_smart_data						= 0xA706,

	/* Trigger */
	en_trig_recv_data						= 0xB001,		/* Send / Recv Flag */

}	ENG_FDPR;

/* Exposoure State */
typedef enum class __en_luria_printing_exposure_state__ : UINT8
{
	en_not_defined							= 0x00,

	en_idle									= 0x01,

	en_preprint_running						= 0x11,
	en_preprint_success						= 0x12,
	en_preprint_failed						= 0x1f,

	en_print_running						= 0x21,
	en_print_success						= 0x22,
	en_print_failed							= 0x2f,
#if 0	/* Not used (Only Here !!!) */
	en_simul_running						= 0x31,
	en_simul_success						= 0x32,
	en_simul_failed							= 0x3f,
#endif
	en_abort_in_progress					= 0xA1,
	en_abort_success						= 0xA2,
	en_abort_failed							= 0xAf,

}	ENG_LPES;

/* Selected Job Load State */
typedef enum class __en_luria_select_load_state__ : UINT8
{
	en_load_none							= 0x00,
	en_load_not_started						= 0x01,
	en_loading								= 0x02,
	en_load_completed						= 0x03,
	en_load_failed							= 0x04,

}	ENG_LSLS;


/* --------------------------------------------------------------------------------------------- */
/*                           전역(Global) 구조체  - Protocol Packet                              */
/* --------------------------------------------------------------------------------------------- */

#pragma pack (push, 1)

/* CMPS → Luria 송신 패킷 구조체 (Big-endian byte ordering) */
typedef struct __st_packet_cmps_luria_send__
{
	UINT16				num_bytes;			/* 자신을 포함한 전체 패킷 크기 */
	UINT8				protocol_version;	/* 프로토콜 버전 */
	UINT8				command_type;		/* 명령어 형식 */
	UINT8				user_data_family;	/* 사용자 데이터가 속한 군 */
	UINT8				user_data_id;		/* 사용자 데이터의 id */
	PUINT8				user_data;			/* command_type, user_data_family, user_data_id 에 따라 사용자 데이터가 결정 */
											/* 대부분 읽기 전용 명령어에는 user_data가 존재하지 않는다. */

	/*
	 desc : Host To Network
	 parm : None
	 retn : None
	*/
	VOID SwapHostToNetwork()
	{
		num_bytes	= htons(num_bytes);
	}

	/*
	 desc : Network To Host
	 parm : None
	 retn : None
	*/
	VOID SwapNetworkToHost()
	{
		num_bytes	= ntohs(num_bytes);
	}

}	STG_PCLS,	*LPG_PCLS;

/* CMPS ← Luria 수신 패킷 구조체 (Big-endian byte ordering) */
typedef struct __st_packet_cmps_luria_recv__
{
	UINT16				num_bytes;			/* 자신을 포함한 전체 패킷 크기 */
	UINT8				protocol_version;	/* 프로토콜 버전 */
	UINT8				command_type;		/* 명령어 형식 (ENG_LTCT) */
	UINT8				user_data_family;	/* 사용자 데이터가 속한 군 */
	UINT8				user_data_id;		/* 사용자 데이터의 id */
	UINT16				status;				/* Luria로부터 응답받아진 상태 */
	PUINT8				user_data;			/* command_type, user_data_family, user_data_id 에 따라 사용자 데이터가 결정 */
											/* 대부분 읽기 전용 명령어에는 user_data가 존재하지 않는다. */

	/*
	 desc : Host To Network
	 parm : None
	 retn : None
	*/
	VOID SwapHostToNetwork()
	{
		num_bytes	= htons(num_bytes);
		status		= htons(status);
	}

	/*
	 desc : Network To Host
	 parm : None
	 retn : None
	*/
	VOID SwapNetworkToHost()
	{
		num_bytes	= ntohs(num_bytes);
		status		= ntohs(status);
	}

	/*
	 desc : PrintSimulationOutDir 명령어인지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsPrintSimulationOutDirCmd()
	{
		return (user_data_family == (UINT8)ENG_LUDF::en_machine_config &&
				user_data_id == (UINT8)ENG_LCMC::en_print_simulation_out_dir);
	}

	/*
	 desc : RootDirectory 명령어인지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsRootDirectoryCmd()
	{
		return (user_data_family == (UINT8)ENG_LUDF::en_job_management &&
				user_data_id == (UINT8)ENG_LCJM::en_root_directory);
	}

	/*
	 desc : GetJobList 명령어인지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsGetJobListCmd()
	{
		return (user_data_family == (UINT8)ENG_LUDF::en_job_management &&
				user_data_id == (UINT8)ENG_LCJM::en_get_job_list);
	}

	/*
	 desc : JobSelected 명령어인지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsSelectedJobCmd()
	{
		return (user_data_family == (UINT8)ENG_LUDF::en_job_management &&
				user_data_id == (UINT8)ENG_LCJM::en_selected_job);
	}

}	STG_PCLR,	*LPG_PCLR;

#pragma pack (pop)	/* 1 bytes order */

/* --------------------------------------------------------------------------------------------- */
/*                                Shared Memory 구조체  - Common                                 */
/* --------------------------------------------------------------------------------------------- */

#pragma pack (push, 1)

/* Luria TCP/IP Data - Common */
typedef struct __st_common_config_int32_x_y__
{
	INT32				x, y;

	VOID SWAP()
	{
		x	= SWAP32(x);
		y	= SWAP32(y);
	}

}	STG_I4XY, *LPG_I4XY;
typedef struct __st_common_config_uint32_x_y__
{
	UINT32				x, y;

	VOID SWAP()
	{
		x	= SWAP32(x);
		y	= SWAP32(y);
	}

}	STG_U4XY, *LPG_U4XY;

#pragma pack (pop)	/* 1 bytes order */


/* --------------------------------------------------------------------------------------------- */
/*                          Shared Memory 구조체 - MachineConfig (0xA0)                          */
/* --------------------------------------------------------------------------------------------- */

#pragma pack (push, 1)

/* Luria TCP/IP Data - Machine Configure (0xA0) (version 2.3.0 or Later (Newer) 기준) */
typedef struct __st_machine_config_table_position_limit__
{
	INT32				min_xy[2];										/* (unit: nm) */
	INT32				max_xy[2];

	VOID SWAP()
	{
		for (UINT8 i=0x00; i<2; i++)
		{
			min_xy[i]	= SWAP32(min_xy[i]);
			max_xy[i]	= SWAP32(max_xy[i]);
		}
	}

	/*
	 desc : 값 초기화
	 parm : None
	 retn : None
	*/
	VOID Reset()
	{
		for (UINT8 i=0x00; i<2; i++)
		{
			min_xy[i]	= 0;
			max_xy[i]	= 0;
		}
	}

	/*
	 desc : 값이 유효하게 설정되어 있는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsValid()
	{
		for (UINT8 i=0x00; i<2; i++)
		{
			if (max_xy[i] < 1)	return FALSE;
		}
		return TRUE;
	}

}	STG_MCTP,	 *LPG_MCTP;

typedef struct __st_machine_config_hysteresis_type1__
{
	UINT8				scroll_mode;									/* 노광 속도 값 (1 ~ 6) (높을수록 속도는 빠르나 광량은 줄어듬) */
	UINT16				negative_offset;								/* Given in number of trigger pulses. pixel (LLS25 -> 1 pixel -> 10.8 um)  */
																		/* Scroll Mode: 1 ~ 4, Negative offset. Pixel Count (1 or Later) (unit: pixel) */
	UINT32				delay_positive;									/* Scroll Mode: 1 ~ 4, 1 Pixel의 이동 지연 시간) (0th: positive, 1th: negative) (unit: nano seconds) */
	UINT32				delay_negative;

	VOID SWAP()
	{
		negative_offset	= SWAP16(negative_offset);
		delay_positive	= SWAP32(delay_positive);
		delay_negative	= SWAP32(delay_negative);
	}

	/*
	 desc : 값 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetData()
	{
		scroll_mode		= 0xff;
		negative_offset	= 0xffff;

		delay_positive	= UINT32_MAX;
		delay_negative	= UINT32_MAX;
	}

	/*
	 desc : 값 존재 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsSetData()
	{
		return ((scroll_mode != 0xff) && (negative_offset != UINT16_MAX) &&
				(delay_positive != UINT32_MAX) && (delay_negative != UINT32_MAX));
	}


}	STG_MCHT,	 *LPG_MCHT;

typedef struct __st_machine_config_photohead_offset__
{
	UINT32				pos_offset_x;									/* 1 번 Photo head 기준으로 2 ~ 8 번의 Photo head X Offset 값 (unit: nm) */
	INT32				pos_offset_y;									/* 1 번 Photo head 기준으로 2 ~ 7 번의 Photo head Y Offset 값 (unit: nm) */

	VOID SWAP()
	{
		pos_offset_x	= SWAP32(pos_offset_x);
		pos_offset_y	= SWAP32(pos_offset_y);
	}

	/*
	 desc : 값 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetData()
	{
		pos_offset_x	= UINT32_MAX;
		pos_offset_y	= INT32_MAX;
	}

	/*
	 desc : 값 설정 여부 반환
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsSetData()
	{
		return (pos_offset_x != UINT32_MAX && pos_offset_y != INT32_MAX);
	}

}	STG_MCPO,	 *LPG_MCPO;

typedef struct __st_machine_config_x_correction_table__
{
	INT32				table_source_x;									/* Table entry 1 ~ N: X-position on table (in nanometers) */
	INT32				table_adjust_x;									/* Table entry 1 ~ N: Adjustment (in nanometers) in the given x-position */

	VOID SWAP()
	{
		table_source_x	= SWAP32(table_source_x);
		table_adjust_x	= SWAP32(table_adjust_x);
	}

}	STG_MCXC,	 *LPG_MCXC;

typedef struct __st_machine_config_y_correction_table__
{
	UINT8				strip_no;										/* Y 축 방향으로 노광한 Strip 간의 상/하 단차 보정 (Strip Number는 1번부터 시작) */
	INT32				table_adjust_y;									/* Y-adjustment for strip number given in entry 1 ~ N (unit: nm) */

	VOID SWAP()
	{
		table_adjust_y	= SWAP32(table_adjust_y);
	}

}	STG_MCYC,	 *LPG_MCYC;

typedef struct __st_luria_data_machine_config__
{
	CHAR				print_simulate_out_dir[MAX_PATH_LEN];			/* Output path name text string (without null-termination) of simulation result files */
	CHAR				custom_edge_blen_bitmap[MAX_PATH_LEN];			/* Path and filename (without null termination) of custom edge blend bitmap */

	UINT8				total_ph;										/* 현재 장비에 운용 중인 포토헤드 총 개수 (1 ~ 8) */
	UINT8				ph_ipv4[MAX_PH][4];								/* Photo head IP Address */
	UINT8				ph_pitch;										/* LLS50:2, LLS25:4, LLS10:8 (단, Photo head가 1개인 경우, 1 값) */
	UINT8				ph_rotate;										/* Photohead 설치 방향 (0 = No rotation, 1 = Rotated 180 degrees) */
	UINT8				motion_control_type;							/* SIEB&MEYER = 1, Newport = 2, 3= ACS */
	UINT8				motion_control_ipv4[4];							/* Motion Control IP address */
	UINT8				table_print_direction[MAX_TABLE];				/* 0: Negative, 1: Positive 방향으로 노광 시작 (최대 테이블 개수만큼) */
	UINT8				active_table;									/* 초기 활성화 하려는 Table Number (Work Table 1 or 2). Double Gantry Type일 경우 고려. Single Stage일 경우, 무조건 1 */
	UINT8				emulate_motor_controller;						/* Luria 서비스가 모터 컨트롤러 연동 여부에 따라 동작 설정 할 수 있도록 설정 */
																		/* 0 = 실제 모터 컨틀로러가 연동되어 동작, 1 = 모터 컨트롤러 없이 동작 가능 */
	UINT8				emulate_ph;										/* Luria 서비스가 포토헤드 연동 여부에 따라 동작 수행할지 여부 설정 */
																		/* 0 = 실제 포토헤드가 연동되어 동작, 1 = 포토헤드 없이 동작 */
	UINT8				emulate_triggers;								/* Luria 서비스가 트리거 연동 여부에 따라 동작 수행할지 여부 설정 */
																		/* 0 = 실제 포토헤드가 연동되어 동작, 1 = 포토헤드 없이 동작 */
	UINT8				debug_print_level;								/* 0: Print info only, 1: Print info and debug, 2: Print info, debug and trace message */
	UINT8				artwork_complexity;								/* Artwork Complexity (거버 복잡도에 따라 값 지정. 정확한 이해는 문서 참조) */
																		/* 보통 0 값 지정 (1 or 2 값의 경우, 포토헤드에 등록되는 거버 개수 제한 됨) */
																		/* 0 = Normal, 1 = High, 2 = eXtrem */
	UINT8				z_drive_type;									/* ZdriveType (포토헤드에 장착된 Motion Drive Type) */
																		/* 1 = Stepper Motor, 2 = Linear drive (ACS), 3 = Linear drive (Sieb & Meyer) */
	UINT8				over_pressure_mode;								/* 포토헤드 내부에 과부하가 발생한 경우 냉각 팬 동작 유무 설정 */
																		/* 1 = Over pressure mode ON, 0 = Over pressure mode OFF */
	UINT8				xy_drive_id[MAX_TABLE][2];						/* 포토헤드 기준 모션 X / Y 축 드라이브 ID (0 ~ 7). At Normal : X = 0, Y = 1 */
	UINT8				mtc_mode;										/* When this is enabled the exposure mode is set to expose each image three times, resulting in smoother edges. It is required that the job is preprocessed with the triple exposure option */
	UINT8				use_ethercat_for_af;							/* When not using ethercat for AF Luria will not try to communicate over ethercat with the z-motion controller */
	UINT8				linear_z_drive_settings[MAX_PH];				/* The ID to be set for the z-axis in the motion controller for this specific photo head. Note! Valid if ZdriveType = 2 only */
	UINT8				z_drive_ipv4[4];								/* IP address of the Z drive (Focus drive). Note! Valid if ZdriveType = 2 only */
	UINT8				extra_long_stripes;								/* 0 = Normal length stripes, 1 = Support for extra long stripes (valid for LLS2500 only) */

	UINT16				scroll_rate;									/* 0 ~ 18000 Hz (Base default : 17000 Hz */
	UINT16				x_correction_table_entry[MAX_TABLE];			/* Table 1/2 에 대한 X 보정 데이터 개수 (0 ~ 200) */
	UINT16				y_correction_table_entry[MAX_TABLE];			/* Table 1/2 에 대한 Y 보정 데이터 개수 (0 ~ 200) */

	UINT16				depth_of_focus;									/* Depth of focus (DOF). Given in number of steps */
																		/* Z 축이 Linear Motor인 경우 유효. 현재 Stepper Motor일 경우 무시 됨 */
	UINT16				spx_level;										/* The spx-level from preprocessed files must correspond to the value set here */
	UINT16				ocp_error_mask;									/* This will mask any OCP errors for the time that is given. This will apply to ALL light sources */
	UINT16				x_correction_count;								/* Number of table entries (N). 0 < N <= 200 */
	UINT16				y_correction_count;								/* Number of table entries (N). 0 < N <= 200 */

	UINT32				parallelogram_adjust[MAX_TABLE];				/* 노광 중 모션(스테이지)을 상/하 이동할 때, 대각선 이동 크기에 */
																		/* Fixed 1 (1000). ex> 0.97 --> 970 (송신 * 1000, 수신 / 1000) */
	UINT32				max_y_motion_speed;								/* 테이블 Y 축 방향의 최대 이동 속도 (단위: um/sec) */
	UINT32				x_motion_speed;									/* 테이블 X 축 이동할 때 속도. 최대 속도 아님 (노광할 때, 노광 시작 위치로 이동하는 속도도 포함) */
	UINT32				y_acceleration_distance;						/* Y 축 가속도가 정상 궤도에 오르기 위한 취소한의 여유 거리 (unit: um) */
	UINT32				product_id;										/* ID identifying the LLS-system. ENG_LPPI (LLS2500 : 16702, LLS04=25002, LLS10 = 50001, LLS25=100001, ...,) */
	UINT32				scroll_mode_delay_pos[MAX_SCROLL_MODE];			/* Position-based delay in positive moving direction. In picometers */
	UINT32				scroll_mode_delay_neg[MAX_SCROLL_MODE];			/* Position-based delay in negative moving direction. In picometers */

	STG_I4XY			table_expo_start_xy[MAX_TABLE];					/* 스테이지 (Table)마다 실제 노광이 시작되는 모션의 위치 값 (unit: um) Only table (stage) number 1 */
	STG_MCTP			table_position_limit[MAX_TABLE];				/* Table 별 (1 / 2 / ...)로 노광할 영역의 최소 X/Y 위치 값 (unit: um) */
	STG_MCHT			hysteresis_type1;
	STG_MCPO			ph_offset_xy[MAX_PH];							/* 1 번 Photo head 기준으로 2 ~ 8 번의 Photo head X / Y Offset 값 (unit: nm) */
																		/* 1 번 배열부터 2번 광학계의 Offset (Step) XY 값이 저장됨. 0번 배열은 0 값으로 비워 둠 */
	STG_I4XY			get_table_motion_start_xy[MAX_TABLE];			/* 노광이 시작하기 위해 이동하는 지점의 모션 X/Y 위치 (unit: um) (가속도 구간 고려) !!! Read Only !!! */

																		/* Table 1 / 2에 대한 보정 전 위치 값이 저장된 버퍼 (단위: nm) */
																		/* Table 1 보정 전 데이터 : x_correction_table_source[0], Table 2 보정 전 데이터 : x_correction_table_source[1] */
																		/* Y 축 방향으로 노광한 Strip 간의 상/하 단차 보정 (Strip Number는 1번부터 시작) */
																		/* 전체 노광할 때, 발생되는 Strip의 개수 (Big Jump가 없다면, 포토헤드 5개이고, PITCH가 4이면 Strip 개수는 총 20개 (1 ~ 20) */
																		/* 1번째 Strip의 보정은 보통 0 값이고, 1번 기준으로 Strip 단차 값 입력 (단위: nm) */
	STG_MCXC			x_correction_table[MAX_TABLE][MAX_X_CORRECTION_TABLE_ENTRY];
	STG_MCYC			y_correction_table[MAX_TABLE][MAX_Y_CORRECTION_TABLE_ENTRY];

	/*
	 desc : HysteresisType1 정보 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetHysteresisType1()
	{
		/* 최대 값으로 초기화 */
		hysteresis_type1.ResetData();
	}

	/*
	 desc : HysteresisType1 정보가 설정되어 있는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsHysteresisType1()
	{
		return hysteresis_type1.IsSetData();
	}

	/*
	 desc : Photohead Offset 정보 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetPhOffset()
	{
		/* 최대 값으로 초기화 */
		for (UINT8 i=0x00; i<MAX_PH; i++)	ph_offset_xy[i].ResetData();
	}

	/*
	 desc : Photohead Offset 정보가 설정되어 있는지 여부
	 parm : ph_no	- [in]  Photohead Number (1-based. !!! Important - Not 0 !!!)
							if (ph_no == 1) then photohead 2 offset
	 retn : TRUE or FALSE
	*/
	BOOL IsPhOffset(UINT8 ph_no)
	{
		return ph_offset_xy[ph_no].IsSetData();
	}

	/*
	 desc : System Settings 정보 초기화
	 parm : init	- [in]  초기화 하려는 값. 0 or 1
	 retn : None
	*/
	VOID ResetSystemSetting(UINT8 init)
	{
		emulate_motor_controller= init;
		emulate_ph				= init;
		emulate_triggers		= init;
		debug_print_level		= 0xff;
	}

	/*
	 desc : System Settings 정보가 설정되어 있는지 여부
	 parm : init	- [in]  비교하려는 값. 0 or 1
	 retn : TRUE or FALSE
	*/
	BOOL IsSystemSetting(UINT8 init)
	{
		return (emulate_motor_controller == init &&
				emulate_ph == init &&
				emulate_triggers == init &&
				debug_print_level != 0xff);
	}

	/*
	 desc : Table Settings 정보 초기화
	 parm : tbl_no	- [in]  1 or 2
	 retn : None
	*/
	VOID ResetTableSetting(UINT8 tbl_no)
	{
		parallelogram_adjust[tbl_no-1]	= 1000;
		table_print_direction[tbl_no-1]	= 1;
		table_position_limit[tbl_no-1].Reset();
	}

	/*
	 desc : Table Settings 정보가 설정되어 있는지 여부
	 parm : tbl_no	- [in]  1 or 2
	 retn : TRUE or FALSE
	*/
	BOOL IsTableSetting(UINT8 tbl_no)
	{
		return (parallelogram_adjust[tbl_no-1] != 1000 && table_print_direction[tbl_no-1] > 0 &&
				table_position_limit[tbl_no-1].IsValid());
	}

	/*
	 desc : Motion Type1 정보 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetMotionType1()
	{
		y_acceleration_distance	= 0;
		active_table			= 0;
	}

	/*
	 desc : Motion Type1 정보가 설정되어 있는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsMotionType1()
	{
		return (y_acceleration_distance > 0 && active_table > 0);
	}

	/*
	 desc : 포토헤드 기본 정보 초기화
	 parm : None
	 retn : None
	 note : 기본정보 : total photohead count, photohead pitch count, scroll rate (hz)
	*/
	VOID ResetAllPHInfo()
	{
		ph_pitch	= 0x00;
		total_ph	= 0x00;
		scroll_rate	= 0x0000;
	}

	/*
	 desc : 포토헤드 기본 정보 값이 존재하는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsSetAllPHInfo()
	{
		return ph_pitch > 0 && total_ph > 0 && scroll_rate > 0;
	}

	/*
	 desc : 기존 설정된 모든 Photohead IPv4 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetPhotoheadsIPv4()
	{
		for (UINT8 i=0x00; i<total_ph; i++)	memset(ph_ipv4[i], 0x00, 4);
	}

	/*
	 desc : 모든 Photohead IPv4 값이 존재하는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsSetPhotoheadsIPv4()
	{
		if (total_ph < 1)	return FALSE;
		for (UINT8 i=0x00; i<total_ph; i++)
		{
			if (ph_ipv4[i][0] < 1)	return FALSE;
		}
		return TRUE;
	}

	/*
	 desc : Motion Control 정보 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetMotionControl()
	{
		motion_control_type	= 0x00;
		max_y_motion_speed	= 0;
		x_motion_speed		= 0;
		memset(motion_control_ipv4, 0x00, 4);
	}

	/*
	 desc : Motion Control 정보가 있는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsMSetotionControl()
	{
		return (motion_control_type > 0 && motion_control_ipv4[0] > 0 &&
				max_y_motion_speed > 0 && x_motion_speed > 0);
	}

}	STG_LDMC,	*LPG_LDMC;

/* --------------------------------------------------------------------------------------------- */
/*                          Shared Memory 구조체 - JobManagement (0xA01)                         */
/* --------------------------------------------------------------------------------------------- */

/* JobManagement - GetFiducials Information */
typedef struct __st_job_management_fiducials_data__
{
	CHAR				hash_value[MAX_HASH_VALUE_COUNT];				/* MAX_HASH_VALUE_COUNT. Hash-value represented as 64 characters */
	/* Global Fiducial의 Coordinate Information */
	INT32				g_d_code;										/* Fiducial D-Code. -1이면, 사용 안됨 */
	UINT16				g_coord_count;									/* Fiducial의 X / Y 쌍의 개수 */
	STG_U4XY			g_coord_xy[MAX_GLOBAL_MARKS];					/* Fiducial의 Coord X / Y 좌표. (단위: nm) */
	/* Local Fiducial의 Coordinate Information */
	INT32				l_d_code;										/* Fiducial D-Code. -1이면, 사용 안됨 */
	UINT16				l_coord_count;									/* Fiducial의 X / Y 쌍의 개수 */
	STG_U4XY			l_coord_xy[MAX_LOCAL_MARKS];					/* Fiducial의 Coord X / Y 좌표. (단위: nm) */

	VOID SWAP()
	{
		UINT16 i	= 0;

		g_d_code		= SWAP32(g_d_code);
		g_coord_count	= SWAP16(g_coord_count);
		for (i=0; i<g_coord_count; i++)	g_coord_xy[i].SWAP();

		l_d_code		= SWAP32(l_d_code);
		l_coord_count	= SWAP16(l_coord_count);
		for (i=0; i<l_coord_count; i++)	l_coord_xy[i].SWAP();
	}
	/*
	 desc : Global or Local 좌표 값 얻기
	 parm : type	- [in]  0x00 : Global, 0x01 : Local
			index	- [in]  Fiducial Index (Zero-based)
			direct	- [in]  0x00 : X Coord., 0x01 : Y Coord.
	 retn : Coordinate-X or Y (단위: nm)
	*/
	UINT32 GetCoord(UINT8 type, UINT32 index, UINT8 direct)
	{
		/* Global Fiducial Information */
		if (0x00 == type)
		{
			if (index >= MAX_GLOBAL_MARKS || direct > 0x01)	return 0;
			return direct==0 ? g_coord_xy[index].x : g_coord_xy[index].y;
		}

		/* Local Fiducial Information */
		if (index >= MAX_LOCAL_MARKS || direct > 0x01)	return 0;
		return direct==0 ? l_coord_xy[index].x : l_coord_xy[index].y;
	}

}	STG_JMFD,	*LPG_JMFD;

/* JobManagement - GetJobParams */
typedef struct __st_job_management_job_param__
{
	CHAR				hash_value[MAX_HASH_VALUE_COUNT];	/* 해쉬 문자 */
	UINT16				version[4];							/* Major - Minor - Sub-minor - Build Version */
	UINT8				ph_count;							/* 거버에 사용되는 포토헤드 개수 */
	UINT8				ph_pitch;							/* 포토헤드 사이에 노광되는 Strip 개수 */
	UINT16				lens_magnification;					/* 렌즈 배율. 1000 값으로 나누기 */
	UINT8				ph_rotated;							/* 1 = rotated, 0 = Not rotated */
	UINT16				strips_counts;						/* 거버 전체의 Strip 개수 */
	UINT16				spx;								/* SPX Level */
	UINT8				flip[2];							/* 거버의 X/Y Flip 여부 */
	UINT16				rotation;							/* 거버의 회전 각도 (단위: degrees) */
	UINT16				pixel_size;							/* Native pixel size (단위: nm) */
	UINT32				artwork_size[2];					/* 거버의 X / Y 크기 (단위: um) */
	UINT8				gerber_inverted;					/* 거버 반전 여부 */
	INT32				erosion[2];							/* 거버의 X / Y Erosion 값 (단위: um) */
	INT32				offset[2];							/* 거버의 X / Y Offset 값 (단위: um) */
	INT32				origin_offset[2];					/* X / Y offset from original gerber orgin (단위: um) */
	UINT32				stripe_overlap;						/* 한 개의 strip에 저장된 여벽이 얼마만큼 겹치는지 ... (단위: um) */
	UINT8				table_print_direction;				/* Y 축 노광 방향. 1 = Positive, 0 = Negative */
	UINT32				product_id;							/* Pre-Processing에서 제공 (지정)한 Product ID */
	UINT32				strip_width;						/* DMD에 의해 한 번 노광된 stripe의 넓이 (폭) (단위: nm) */
	UINT8				edge_blend_enabled;					/* 0 = No edge blending, 1 = Edge blending enabled (Available from version 2.11.0) */
	UINT8				extra_long_strips;					/* 0 = Normal length strips, 1 = Extra long strips (Available from version 2.11.0) */
	UINT8				mtc_mode;							/* 0 = Normal exposure mode, 1 = MTC exposure mode (Available from version 3.00.0) */

	VOID SWAP()
	{
		UINT8 i	= 0x00;
		for (i=0; i<4; i++)	version[i]	= SWAP16(version[i]);
		lens_magnification	= SWAP16(lens_magnification);
		strips_counts		= SWAP16(strips_counts);
		spx					= SWAP16(spx);
		rotation			= SWAP16(rotation);
		pixel_size			= SWAP16(pixel_size);
		for (i=0; i<2; i++)
		{
			artwork_size[i]	= SWAP32(artwork_size[i]);
			erosion[i]		= SWAP32(erosion[i]);
			offset[i]		= SWAP32(offset[i]);
			origin_offset[i]= SWAP32(origin_offset[i]);
		}
		stripe_overlap	= SWAP32(stripe_overlap);
		product_id		= SWAP32(product_id);
		strip_width		= SWAP32(strip_width);
	}

	/*
	 desc : 값이 유효한지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsValidData()
	{
		return pixel_size > 0 && product_id > 0 && strip_width > 0 && strips_counts > 0;
	}

}	STG_JMJP,	*LPG_JMJP;

/* JobManagement - GetPanelDataDcodeList */
typedef struct __st_job_management_paneldata_decode_list__
{
	UINT16				count;								/* 거버 내에 등록된 D-Code 개수 */
	UINT32				d_code[MAX_DCODE_LIST];				/* 'count' 만큼 등록된 D-Code Number */

	VOID SWAP()
	{
		count	= SWAP16(count);
		for (UINT16 i=0; i<count; i++)	d_code[i]	= SWAP32(d_code[i]);
	}

}	STG_JMPL,	*LPG_JMPL;

/* JobManagement - GetPanelDataInfo */
typedef struct __st_job_management_panel_data_info__
{
	UINT8				type;					/* ENG_PDTC (0x00 ~ 0x02) */
	UINT8				content;				/* ENG_PDCC (0x00 ~ 0x02) */
	UINT16				rotation;				/* Rotation. In degrees */
	UINT8				inverse;				/* Inverse panel data. 0 = Not inverted, 1 = Inverted */
	UINT32				size[2];				/* Panel size (Width / Height) */
	UINT16				location_count;			/* Coordinate X/Y 개수. 최대 400 */
	STG_U4XY			coord_xy[MAX_COORD_XY];	/* Coordinate X/Y 가 저장된 버퍼. X/Y 순서 쌍으로 저장 (단위: nm) */

	VOID SWAP()
	{
		rotation		= SWAP16(rotation);
		size[0]			= SWAP32(size[0]);
		size[1]			= SWAP32(size[1]);
		location_count	= SWAP16(location_count);
		for (UINT16 i=0; i<location_count; i++)	coord_xy[i].SWAP();
	}

	/*
	 desc : Location 위치에 대한 Coordinate X/Y 값 반환 (단위: nm)
	 parm : index	- [in]  가져오고자 하는 Coordniate 위치 (Zero-base. 최대 399)
			direct	- [in]  0x00: Coord. X, 0x01: Coord. Y
	 retn : Coordinate-X or Y 값 반환 (단위: nm)
	*/
	UINT32 GetLocationCoord(UINT16 index, UINT8 direct)
	{
		if (index >= MAX_COORD_XY || direct > 1)	return 0;

		return direct==0 ? coord_xy[index].x : coord_xy[index].y;
	}

}	STG_JMPD,	*LPG_JMPD;

/* Luria TCP/IP Data - Job Management (0xA1) (version 2.3.0 or Later (Newer) 기준) */
typedef struct __st_luria_data_job_management__
{
	UINT8				max_job_regist;						/* 등록 가능한 JOB 개수 */
	UINT8				job_regist_count;					/* 현재 등록된 JOB 개수 */
	UINT8				selected_job_load_state;			/* 선택된 Job Load 상태 즉, ENG_LSLS */
	/* 아래 3개 변수는 위의 selected_job_load_state가 Loading 중일 때만 의미가 있음 */
	UINT8				job_state_ph_loaded;				/* 포토헤드에 Job이 모두 적재되었는지 여부 */
	UINT8				job_state_strip_loaded;				/* 포토헤드에 Job 중 Strip이 적재된 개수 */
	UINT8				job_total_strip_loaded;				/* 포토헤드에 Job 중 총 적재될 Strip rotn */

	CHAR				root_directory[MAX_PATH_LEN];		/* Preprocessing 결과 이미지 파일이 저장될 절대 경로 (NULL이면, 거버 파일 저장 경로가 사용됨) */
															/* 최대 등록 가능한 Job Path Name 등록 버퍼 위치 */
	CHAR				job_name_list[MAX_REGIST_JOB_LIST][MAX_GERBER_NAME];
	CHAR				selected_job_name[MAX_GERBER_NAME];	/* 현재 선택된 Job Path Name */

	UINT32				selected_d_code;					/* 현재 선택된 Job Path Name의 D Code 값 */

	STG_JMFD			selected_job_fiducial;				/* 현재 선택된 Job Path Name의 Fiducial Information 저장 됨 */
	STG_JMJP			get_job_params;						/* 현재 선택된 Job Parameters 정보 저장 됨 */
	STG_JMPL			selected_job_dcode_list;			/* 현재 선택된 Job Path Name의 D-Code 리스트 정보 (거버 내에 등록된 D-Code 리스트) */
	STG_JMPD			selected_job_panel_data;			/* 현재 선택된 Job Path Name의 Panel Data 정보 저장 됨 */

	/*
	 desc : Check if all data of the gerber is loaded
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsLoadedGerber()
	{
#if 0
		return job_state_ph_loaded == 0x01 ? TRUE : FALSE;
#else
		return job_state_strip_loaded == job_total_strip_loaded;
#endif
	}
	
	/*
	 desc : 현재 거버 적재율 값 반환
	 parm : None
	 retn : 거버 적재율 값 (단위: percent)
	*/
	DOUBLE GetLoadRate()
	{
		return (job_state_strip_loaded * 100.0f) / (job_total_strip_loaded * 1.0f);
	}

	/*
	 desc : 기존 선택 및 적재된 거버 정보 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetLoadedRecipe()
	{
		selected_job_load_state	= (UINT8)ENG_LSLS::en_load_none;
		selected_d_code			= 0;
		memset(&selected_job_fiducial,	0x00, sizeof(STG_JMFD));
		memset(&selected_job_dcode_list,0x00, sizeof(STG_JMPL));
		memset(&selected_job_panel_data,0x00, sizeof(STG_JMPD));
		memset(&get_job_params,			0x00, sizeof(STG_JMJP));
	}

	/*
	 desc : Job Param 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetJobParam()
	{
		memset(&get_job_params, 0x00, sizeof(STG_JMJP));
	}

	/*
	 desc : 기존 작업 적재 정보 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetJobLoaded()
	{
		job_state_ph_loaded		= 0x00;		/* 포토헤드에 Job이 모두 적재되었는지 여부 */
		job_state_strip_loaded	= 0x00;		/* 포토헤드에 Job 중 Strip이 적재된 개수 */
	}
	
	/*
	 desc : 현재 선택된 Job Name 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetSelectedJobName()
	{
		selected_d_code			= 0;
		selected_job_load_state	= (UINT8)ENG_LSLS::en_load_none;
		memset(selected_job_name, 0x00, MAX_GERBER_NAME);
		memset(&selected_job_fiducial, 0x00, sizeof(STG_JMFD));
		memset(&get_job_params, 0x00, sizeof(STG_JMJP));
		memset(&selected_job_dcode_list, 0x00, sizeof(STG_JMPL));
		memset(&selected_job_panel_data, 0x00, sizeof(STG_JMPD));
	}

	/*
	 desc : 기존에 등록된 Job Name List 모두 제거
	 parm : None
	 retn : None
	*/
	VOID ResetJobNameList()
	{
		UINT8 i	= 0x00;
		for (; i<MAX_REGIST_JOB_LIST; i++)	memset(job_name_list[i], 0x00, MAX_GERBER_NAME);
		job_regist_count	= 0x00;
		ResetSelectedJobName();
		ResetLoadedRecipe();
	}

	/*
	 desc : 현재 수신된 Job Name이 있다면 위치 반환
	 parm : None
	 retn : 존재하면 0x00 ~ xxx, 없다면 -1
	*/
	INT32 GetJobRegisteredLastIndex()
	{
		INT8 i	= 0x00;
		/* 현재 수신된 Job List가 있는지 확인 */
		for (i=MAX_REGIST_JOB_LIST-1; i>=0; i--)
		{
			if (strlen(job_name_list[i]) > 0)	return i;
		}
		return -1;
	}

	/*
	 desc : 가장 마지막에 등록된 Job의 내용 초기화
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL ResetJobRegisteredLast()
	{
		INT8 i		= 0x00;
		BOOL bReset	= FALSE;
		/* 현재 수신된 Job List가 있는지 확인 */
		for (i=MAX_REGIST_JOB_LIST-1; i>=0; i--)
		{
			bReset	= strlen(job_name_list[i]) > 0;
			if (bReset)
			{
				memset(job_name_list[i], 0x00, MAX_GERBER_NAME);
				break;
			}
		}
		return bReset;
	}

	/*
	 desc : 현재 선택된 Job Name의 위치 얻기
	 parm : None
	 retn : 음수 (-1) : 선택된 Job Name 얻기 실패, 0 or Later
	*/
	INT8 GetJobNameSelectedIndex()
	{
		UINT8 i	= 0x00;

		if (strlen(selected_job_name) < 1 || job_regist_count < 1)	return -1;
		/* 현재 선택된 Job Name의 위치 얻기 */
		for (; i<job_regist_count; i++)
		{
			if (0 == strcmp(selected_job_name, job_name_list[i]))	return INT8(i);
		}
		return -1;
	}
	/*
	 desc : 다음에 선택될 Job Name의 인덱스 위치 얻기 (Zero-based)
	 parm : None
	 retn : 음수 (-1):선택된 Job Name 없음. 0 or Later
	*/
	INT8 GetNextJobNameSelectIndex()
	{
		INT8 i8Sel;

		/* 선택된 Job Name이 없거나, 등록된 Job Name이 없는지 확인 */
		if (strlen(selected_job_name) < 1 || job_regist_count < 1)	return -1;
		/* 등록된 Job Name이 1개 뿐이면 무조건 0 반환 */
		if (job_regist_count == 0x01)	return 0x00;

		/* 현재 선택된 Job Name의 위치 얻기 */
		i8Sel	= GetJobNameSelectedIndex();
		if (i8Sel < 0)	return i8Sel;

		/* 현재 선택된 값 1 증가 시키고, 만약 증가된 값이 등록된 개수가 동일하면 0 으로 설정 */
		if (++i8Sel >= job_regist_count)	i8Sel	= 0x00;

		return i8Sel;
	}

	/*
	 desc : 기존에 등록된 Job Name이 있는지 여부
	 parm : name	- [in]  검색하려는 Job Name
	 retn : TRUE - 이미 등록된 Job Name이다. FALSE - 등록 안된 Job Name이다.
	*/
	BOOL IsJobOnlyFinded(PCHAR name)
	{
		UINT8 i	= 0x00;
		PCHAR pszFind	= NULL;

		for (; i<job_regist_count; i++)
		{
			/* 등록된 Job Name이 없는 경우인지 확인 */
			if (strlen(job_name_list[i]) > 0)
			{
				/* 마지막에 디렉토리 구분 ('/')이 있는 곳 검색 */
				pszFind	= strrchr(job_name_list[i], '\\') + 1;
				/* 동일한 Job Name인지 검사 */
				if (pszFind && (0 == strcmp(name, pszFind)))	return TRUE;
			}
		}

		return FALSE;
	}

	/*
	 desc : 기존에 등록된 Job Name이 있는지 여부
	 parm : name	- [in]  검색하려는 Job Name (전체 경로 포함)
	 retn : TRUE - 이미 등록된 Job Name이다. FALSE - 등록 안된 Job Name이다.
	*/
	BOOL IsJobFullFinded(PCHAR name)
	{
		UINT8 i	= 0x00;

		for (; i<job_regist_count; i++)
		{
			/* 동일한 Job Name인지 검사 */
			if (strlen(job_name_list[i]) > 0 &&
				(0 == strcmp(name, job_name_list[i])))
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	/*
	 desc : 현재 위치에 등록된 Job Name이 있는지 여부
	 parm : index	- [in]  등록 위치 (인덱스) (0 ~ MAX_REGIST_JOB_LIST-1)
	 retn : TRUE or FALSE
	*/
	BOOL IsRegisteredJobName(UINT8 index)
	{
		if (index >= MAX_REGIST_JOB_LIST)	return FALSE;
		return strlen(job_name_list[index]) > 0 ? TRUE : FALSE;
	}

	/*
	 desc : 현재 선택된 Job Name이 있는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsJobNameSelected()
	{
		return strlen(selected_job_name) > 0 ? TRUE : FALSE;
	}

	/*
	 desc : 현재 선택된 Job Name이 Loaded 되었는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsJobNameLoadCompleted()
	{
		return (selected_job_load_state == (UINT8)ENG_LSLS::en_load_completed &&
				job_state_ph_loaded == 0x00 /* If it is 0x01, Loading... */);
	}

	/*
	 desc : 현재 Job Name이 등록되었고, 선택 되었고, 적재가 완료된 상태인지 (IsJobNameLoadCompleted 기능 확장)
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsJobNameRegistedSelectedLoaded()
	{
		if (strlen(selected_job_name) < 1)
		{
			return FALSE;
		}
#if 0	/* 부하 많이 걸린다... ? */
		if (!IsJobFinded(selected_job_name))	return FALSE;
#endif
		return IsJobNameLoadCompleted();
	}

	/*
	 desc : 현재 선택된 Job Name이 Loaded 되었는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsJobNameLoadFailed()
	{
		return selected_job_load_state == (UINT8)ENG_LSLS::en_load_failed;
	}

	/*
	 desc : 현재 선택된 Job Name의 길이 반환
	 parm : None
	 retn : 이름 길이
	*/
	UINT32 GetSelectedJobSize()
	{
		if (!IsJobNameSelected())	return 0;
		return (UINT32)strlen(selected_job_name);
	}

	/*
	 desc : 등록된 Job Names가 있는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsRegisteredJobs()
	{
		return job_regist_count > 0;
	}

}	STG_LDJM,	*LPG_LDJM;

/* --------------------------------------------------------------------------------------------- */
/*                        Shared Memory 구조체 - PanelPreparation (0xA02)                        */
/* --------------------------------------------------------------------------------------------- */

/* Panel Preparation - DynamicFiducials or Registration Points */
typedef struct __st_panel_preparation_dynamic_global__
{
	UINT16				g_count;
	STG_I4XY			g_coord_xy[MAX_GLOBAL_MARKS];

	VOID SWAP()
	{
		g_count		= SWAP16(g_count);
		for (UINT16 i=0; i<g_count; i++)
		{
			g_coord_xy[i].SWAP();
		}
	}

}	STG_PPDG,	*LPG_PPDG;

typedef struct __st_panel_preparation_dynamic_local__
{
	UINT16				l_count;
	STG_I4XY			l_coord_xy[MAX_LOCAL_MARKS];

	VOID SWAP()
	{
		l_count		= SWAP16(l_count);
		for (UINT16 i=0; i<l_count; i++)
		{
			l_coord_xy[i].SWAP();
		}
	}

}	STG_PPDL,	*LPG_PPDL;

typedef struct __st_panel_preparation_registration_points__
{
	UINT16				r_count;
	STG_I4XY			r_coord_xy[MAX_REGISTRATION_POINTS];

	VOID SWAP()
	{
		r_count		= SWAP16(r_count);
		for (UINT16 i=0; i<r_count; i++)
		{
			r_coord_xy[i].SWAP();
		}
	}

}	STG_PPRP,	*LPG_PPRP;

/* Panel Preparation - GetTransformationParams */
typedef struct __st_panel_preparation_transformation_params__
{
	UINT16				zone_number;								/* 0 = Global, 1 and abover: local zone numbers */

	INT32				rotation;									/* (unit: micro-degreses) */
	UINT32				scale_xy[2];								/* X / Y scaling factor * 10^6. ex> 1.0002 = 1000200 */
	INT32				offset_xy[2];								/* (unit: nm) */
	UINT16				fiducial_coord_group_count;					/* Number of fiducial coordinate groups (N) */
	STG_I4XY			fiducial_coord_xy[MAX_REGISTRATION_POINTS];	/* X / Y Coordniate fiducial point (unit: nm) */

	VOID SWAP()
	{
		zone_number					= SWAP16(zone_number);
		fiducial_coord_group_count	= SWAP16(fiducial_coord_group_count);
		for (UINT8 i=0; i<2; i++)
		{
			scale_xy[i]		= SWAP32(scale_xy[i]);
			offset_xy[i]	= SWAP32(offset_xy[i]);
		}
		for (UINT16 i=0; i<fiducial_coord_group_count; i++)	fiducial_coord_xy[i].SWAP();
	}

}	STG_PPTP,	*LPG_PPTP;

/* Panel Preparation - PanelDataSerialNumber */
typedef struct __st_panel_preparation_serial_number__
{
	UINT32				d_code;								/* D-code */
	UINT8				horz_flip;							/* 1: flip, 0: No flip */
	UINT8				vert_flip;							/* 1: flip, 0: No flip */
	UINT16				horz_font_size;						/* unit: nm, 자동 모드 원하면 0 값 */
	UINT16				vert_font_size;						/* unit: nm, 자동 모드 원하면 0 값 */
	UINT8				symbol_mark;						/* ex> '#', '@', etc */
	UINT32				start_num;
	UINT16				string_len;
	CHAR				serial_str[MAX_PANEL_SERIAL_STRING];

	VOID SWAP()
	{
		horz_font_size	= SWAP16(horz_font_size);
		vert_font_size	= SWAP16(vert_font_size);
		string_len		= SWAP16(string_len);
		d_code			= SWAP32(d_code);
		start_num		= SWAP32(start_num);
	}

}	STG_PPSN,	*LPG_PPSN;

/* Panel Preparation - PanelDataSerialNumber */
typedef struct __st_panel_preparation_panel_data__
{
	UINT32				d_code;								/* D-code */
	UINT8				horz_flip;							/* 1: flip, 0: No flip */
	UINT8				vert_flip;							/* 1: flip, 0: No flip */
	UINT16				horz_font_size;						/* unit: nm, 자동 모드 원하면 0 값 */
	UINT16				vert_font_size;						/* unit: nm, 자동 모드 원하면 0 값 */
	UINT16				string_len;
	CHAR				text_str[MAX_PANEL_TEXT_STRING];

	VOID SWAP()
	{
		horz_font_size	= SWAP16(horz_font_size);
		vert_font_size	= SWAP16(vert_font_size);
		string_len		= SWAP16(string_len);
		d_code			= SWAP32(d_code);
	}

}	STG_PPPD,	*LPG_PPPD;

/* Panel Preparation - GetWarpOfLimitsCoordinates */
typedef struct __st_panel_preparation_warp_limits__
{
	UINT32				coord_xy[2];						/* unit: um */
	UINT32				error_xy[2];						/* unit: um */

	VOID SWAP()
	{
		for (UINT8 i=0; i<2; i++)
		{
			coord_xy[i]	= SWAP32(coord_xy[i]);
			error_xy[i]	= SWAP32(error_xy[i]);
		}
	}

}	STG_PPWL,	*LPG_PPWL;

/* Luria TCP/IP Data - Panel Preparation (0xA2) (version 2.3.0 or Later (Newer) 기준) */
typedef struct __st_luria_data_panel_preparation__
{
	UINT8				global_transformation_recipe[3];				/* [0] Rotation, [1] Scaling, [2] Offset, 0:Auto, 1:Fixed */
	UINT8				use_shared_local_zones;							/* 1: Use shared zones, 0: Do not use shared zoned */
	UINT8				local_transformation_recipe;					/* Bit 0 => 0: Auto, 1:Fixed, Bit 1 ~ 3 (Rotaion, Scale, Offset) */
	UINT8				global_rectangle_lock;							/* 1: 강제로 Rectangle Lock, 0: 강제로 Rectangle Locl 하지 않음 (기본 값) */
	UINT8				snap_to_zone_mode;								/* When this mode is enabled, the artwork is always warped to the closest zone registration setting */

	UINT16				registration_pair_xy_count;						/* 얼라인 카메라에 의해 검사된 X/Y의 개수 (최대 400) */
	UINT16				local_zone_geometry_xy[2];						/* Number of fiducial points in X/Y direction for one zone (1개의 Zone에 X/Y로 몇 개씩 존재하는지) */
	UINT16				get_number_of_local_zones;						/* 계산된 Local Zone 개수 */
	UINT16				get_registration_status;						/* 현재 Registration Status 값 (ENG_PDRS) */
	UINT16				local_fixed_rotation_cnt;						/* Local Zone 개수 (최대 200) */
	UINT16				local_fixed_scaling_cnt;						/* Local Zone 개수 (최대 200) */
	UINT16				local_fixed_offset_cnt;							/* Local Zone 개수 (최대 200) */
	UINT16				warp_limit_coord_xy_cnt;						/* Warp Coordinate 개수 (최대 400) */

	INT32				global_fixed_rotation;							/* Global fixed rotation, in micro-degrees */
	INT32				global_fixed_offset_xy[2];						/* Global fixed X/Y-offset (단위: nm) */
	UINT32				global_fixed_scaling_xy[2];						/* Global fixed X/Y-scaling factor * 10^6 */

	STG_PPDG			fiducial_global;								/* 동적으로 등록할 수 있는 Global Fiducial (단위: nm) */
	STG_PPDL			fiducial_local;									/* 동적으로 등록할 수 있는 Local Fiducial (단위: nm) */
	STG_PPRP			registration_points;							/* 등록된 마크 좌표 정보 영역 (단위: nm) */

	STG_PPTP			get_transformation_params;						/* 가장 최근에 요청한 Transformation Params 정보 */
	STG_PPSN			panel_data_serial_number;						/* 가장 최근에 요청한 Panel Data Serial Number 정보 */
	STG_PPPD			panel_data;
	STG_PPWL			warp_limits_coord_xy[MAX_WARP_COORD_XY];		/* */

	INT32				local_fixed_rotation[MAX_LOCAL_FIXED_COUNT];	/* 최대 200 개임 */
	STG_U4XY			local_fixed_scaling[MAX_LOCAL_FIXED_COUNT];		/* 최대 200 개임 */
	STG_I4XY			local_fixed_offset[MAX_LOCAL_FIXED_COUNT];		/* 최대 200 개임 */

	/*
	 설명 : 좌표 정보 얻기
	 변수 : type	- [in]  좌표 대상의 구분 (ENG_PDCT)
			index	- [in]  저장된 메모리 위치 (Zero-based)
			direct	- [in]  0x00: Coord. X, 0x01: Coord. Y
	 반환 : 좌표 값 (단위: nm)
	*/
	UINT32 GetLocationCoord(ENG_PDCT type, UINT16 index, UINT8 direct)
	{
		switch(type)
		{
		case ENG_PDCT::en_dynamic_fiducial_global:
			if (index >= MAX_GLOBAL_MARKS)			return 0;
			return direct == 0x00 ? fiducial_global.g_coord_xy[index].x : fiducial_global.g_coord_xy[index].y;
		case ENG_PDCT::en_dynamic_fiducial_local	:
			if (index >= MAX_LOCAL_MARKS)			return 0;
			return direct == 0x00 ? fiducial_local.l_coord_xy[index].x : fiducial_local.l_coord_xy[index].y;
		case ENG_PDCT::en_registration_point		:
			if (index >= MAX_REGISTRATION_POINTS)	return 0;
			return direct == 0x00 ? registration_points.r_coord_xy[index].x : registration_points.r_coord_xy[index].y;
		}

		return 0;
	}

	/*
	 설명 : Retset the Global Transformation Recipe
	 변수 : None
	 반환 : None
	*/
	VOID ResetGlobalTransRecipe()
	{
		global_rectangle_lock			= 0xff;
		global_transformation_recipe[0]	= 0xff;
		global_transformation_recipe[1]	= 0xff;
		global_transformation_recipe[2]	= 0xff;
		global_fixed_rotation		= INT32_MAX;
		global_fixed_offset_xy[0]	= INT32_MAX;
		global_fixed_offset_xy[1]	= INT32_MAX;
		global_fixed_scaling_xy[0]	= UINT32_MAX;
		global_fixed_scaling_xy[1]	= UINT32_MAX;
	}

}	STG_LDPP,	*LPG_LDPP;

/* --------------------------------------------------------------------------------------------- */
/*                           Shared Memory 구조체 - Exposure (0xA03)                             */
/* --------------------------------------------------------------------------------------------- */

/* Exposure - GetNumberOfLightSource */
typedef struct __st_exposure_work_led_info__
{
	UINT8				led_count;							/* 이용 가능한 주파수 개수 (265, 385, 395, 405) */
	UINT8				led_type;							/* 0:LED, 1:Laser, 2:LED combiner */

}	STG_EWLI,	*LPG_EWLI;

/* Exposure - AFSensor */
typedef struct __st_exposure_work_af_sensor__
{
	UINT8				sensor_type;						/* 1: Diffuse (퍼짐), 2:Specular (반사광) */
	UINT8				agc_type;							/* 1:AGC ON (기본), 0,2:AGC OFF. 2일 경우, 측정된 PWM 값이 사용됨 */
	UINT16				agc_value;							/* Laser에 대한 PWM 값. (AGC Off 상태이어야 하고, Range:2~511. 기본 값은 100) */

	/* 2 or 4 bytes Big or Little endian */
	VOID SWAP()
	{
		agc_value	= SWAP16(agc_value);
	}

}	STG_EWAS,	*LPG_EWAS;

/* Exposure - AFSensorMeasureLaserPWM */
typedef struct __st_exposure_work_af_pwm__
{
	UINT8				meas_count;							/* 전체 측정된 개수 (Photohead마다 1개씩 임). 결국 Photohead 개수 */
	UINT16				pwm_value[MAX_PH];					/* 측정된 PWM 값 (2 ~ 511) */

	/* 2 or 4 bytes Big or Little endian */
	VOID SWAP()
	{
		UINT8 i	= 0;
		for (; i<meas_count; i++)	pwm_value[i]	= SWAP16(pwm_value[i]);
	}

}	STG_EWAP,	*LPG_EWAP;

/* Exposure - GetLightSourceStatusMulti */
typedef struct __st_exposure_work_light_source__
{
	UINT8				ph_count;							/* 전체 Photohead 개수 */
	UINT8				led_count;							/* 각 Photohead마다 설치된 LED 개수 */
	UINT8				led_type;							/* 0:LED, 1:Laser, 2:LED combiner, 4:Knife edge laser */
	UINT8				led_connect[MAX_PH][MAX_LED];		/* 0: Not connect, 1: connected*/
	UINT32				status[MAX_PH][MAX_LED];

	/* 2 or 4 bytes Big or Little endian */
	VOID SWAP()
	{
		UINT8 i	= 0, j = 0;
		for (; i<ph_count; i++)
		{
			for (j=0; j<led_count; j++)	status[i][j]	= SWAP32(status[i][j]);
		}
	}

}	STG_EWLS,	*LPG_EWLS;

typedef struct __st_luria_data_exposure_work__
{
	UINT8				get_exposure_state[3];					/* 현재 노광 상태 값 (exposure state (ENG_LPES) / Last completed print motion / Total number of print motions for the job) */
	UINT8				scroll_step_size;						/* Step Size (Scroll Mode) (1 ~ 4) */
	UINT8				led_duty_cycle;							/* LED duty cycle (Rangle: 0 ~ 100%) */
																/* 이 명령은 모든 포토 헤드에 LED의 On-time 시간 주기를 설정 */
																/* LED on-time = (1 / (scroll_rate * scroll_step_size * frame_rate_factor)) * led_duty_cycle/100 */
	UINT8				enable_af_copy_last_strip;				/* Enable AF copy 기능 적용 여부. 2번째 Strip의 Autofocus Profile을 마지막 Strip에 복사할지 말지 결정 */
	UINT8				disable_af_first_strip;					/* 첫 번째 포토헤드의 첫 Strip에 대한 Autofocus 동작 여부 설정. 0:Disable, 1:Not disable (기본 값) (반대 개념이니. 꼭 확인) */
	UINT8				af_sensor_measured_count;				/* AFSensorMeasureLaserPWM - 측정된 개수 즉, 포토헤드 개수 */
	UINT8				available_light_source_cnt[MAX_PH];		/* Photohead 마다 이용 가능한 LED 개수 (설치된 개수 아님) */
	UINT8				light_source_type[MAX_PH];				/* Photohead 마다 설치된 Light Source Type (0:LED, 1:Laser, 2: LED Combiner) */

	UINT16				led_amplitude_power[MAX_PH][MAX_LED];	/* 4개 파장(365nm, 385nm, 395nm, 405nm) 에 최대 8개 Photohead 지원. Led Power Index 값 (0x0000 (0) ~ 0x0fff (4095) */
	UINT16				frame_rate_factor;						/* Frame Rate 값 설정 (0 < frame_rate_factor / 1000 <= 1 (Rangle: 1 ~ 1000) */
	UINT16				af_sensor_measured_value[MAX_PH];		/* AFSensorMeasureLaserPWM - 측정된 개수 즉, 포토헤드에 적용된 측정된 PWM 값 */

	UINT32				get_exposure_speed;						/* 노광 중에 사용 중인 모션 속도 (unit: um/sec) */
																/* speed = scroll_rate * pixel_size * scroll_step_size * frame_rate_factor */
	STG_EWLI			light_source_info[MAX_PH];				/* Light Source Property (LED Count, LED Kind) */
	STG_EWAS			af_sensor;								/* Autofocus Sensor 관련 정보 */
	STG_EWAP			af_pwm;									/* Autofocus Sensor (for laser)의 PWM 값 */
	STG_EWLS			light_source_status;					/* Photohead 내에 설치된 Light Source의 상태 값 */

	bool autofocusEnable; //오토포커스 작동여부
	/*
	 desc : 현재까지 노광한 Scan line 개수 (전체 노광 개수가 아님)
	 parm : None
	 retn : Scan Line 개수 (노광한 개수)
	*/
	UINT8 GetScanLine()
	{
		return get_exposure_state[1];
	}
	/*
	 desc : 전체 노광할 Scan line 개수 (전체 노광 개수)
	 parm : None
	 retn : Scan Line 개수 (총 노광 개수)
	*/
	UINT8 GetScanTotal()
	{
		return get_exposure_state[2];
	}
	
	/*
	 desc : Duty Cycle, Step Size 그리고 Frame Rate 값 초기화
	 parm : None
	 retn : None
	*/
	VOID SetDutyStepFrame()
	{
		led_duty_cycle		= 0;
		scroll_step_size	= 0;
		frame_rate_factor	= 0;
	}

	/*
	 desc : Duty Cycle, Step Size 그리고 Frame Rate 값이 모두 설정되어 있는지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsSetDutyStepFrame()
	{
		return led_duty_cycle > 0 && scroll_step_size > 0 && frame_rate_factor > 0;
	}

	/*
	 desc : LED Power Index & Watt 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetPowerIndex()
	{
		UINT8 i	= 0x00;
		for (; i<MAX_PH; i++)	memset(led_amplitude_power[i], 0xff, sizeof(UINT16) * MAX_LED);
	}

	/*
	 desc : LED Power Index와 Watt 값이 설정되어 있는지 여부
	 parm : ph_cnt	- [in]  검사 대상의 Photohead Count
	 retn : TRUE or FALSE
	*/
	BOOL IsSetPowerIndex(UINT8 ph_cnt)
	{
		UINT16 i	= 0x00;

		if (ph_cnt > MAX_PH)	ph_cnt	= MAX_PH;
		for (; i<ph_cnt; i++)
		{
			if (led_amplitude_power[i][0] == 0xffff ||
				led_amplitude_power[i][1] == 0xffff ||
				led_amplitude_power[i][2] == 0xffff ||
				led_amplitude_power[i][3] == 0xffff)	return FALSE;
		}
		return TRUE;
	}

	/*
	 desc : 노광 진행 상태 값 초기화
	 parm : None
	 retn : None
	*/
	VOID ResetExposeState()
	{
		get_exposure_state[0]	= 0x01;	/* Idle 상태로 변경 */
	}

	/*
	 desc : 현재 노광 상태가 Idle인지 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsWorkIdle()
	{
		UINT8 u8State	= get_exposure_state[0];	/* ENG_LPES */

#if 1
		return ((u8State != 0x01) && (0x01 != (u8State & 0x01))) ? TRUE : FALSE;
#else
		/* If It is idle, then return FASLE */
		if ((UINT8(ENG_LPES::en_idle) == (u8State & 0x0f)) ||
			(UINT8(ENG_LPES::en_preprint_running)	!= u8State &&
			 UINT8(ENG_LPES::en_print_running)		!= u8State &&
			 UINT8(ENG_LPES::en_abort_in_progress)	!= u8State))	return TRUE;	/* Idle */
#endif
	}


}	STG_LDEW,	*LPG_LDEW;

/* --------------------------------------------------------------------------------------------- */
/*                       Shared Memory 구조체 - Direct Photohead (0xA04)                         */
/* --------------------------------------------------------------------------------------------- */

typedef struct __st_luria_data_direct_photohead__
{
	UINT8				enable_flatness_correction_mask[MAX_PH];			/* 1: Enable, 0: Disabled*/
	UINT8				load_internal_image[MAX_PH];						/* The internal image number to be displayed. Range: 0 ~ 5 */
	UINT8				active_sequence_file[MAX_PH];						/* 0: Use last loaded (external) sequence file, 1: Use internal sequence file */
	UINT8				light_source_driver_light_onoff[MAX_PH][MAX_LED];	/* LED Power On/Off (1 ~ 8. PH 마다 LED 4) */
	UINT8				light_source_info[MAX_PH][2];						/* [0:type] 0:LED Combinaer v1, 1:Laser, 2:LED Combiner v2, 3: LRS-HY driver, [1:connect count] (1 (TYPE) + 1 (Connected count)) * 8 */
	UINT8				camera_illumination_led[MAX_PH];					/* 각 광학계에 설치된 LED 조명 밝기 값 (Max 8) */
	UINT8				camera_led_power_onoff[MAX_PH];						/* 각 광학계에 설치된 LED 전원 On or Off (Max 8) */
	UINT8				line_sensor_plot[MAX_PH];							/* 각 광학계의 Line Sensor Plot Enable 여부 */
	UINT8				dmd_flip_output[MAX_PH];							/* 각 광학계에 설치된 DMD Flip 설정 여부 (Max 8) */
	UINT8				dmd_mirror_shake[MAX_PH];							/* 0x00:DMD mirror shake OFF, 0x01:DMD mirror shake ON (Max 8) */
	UINT8				light_source_on_time_read_ok[MAX_PH][MAX_LED];		/* LED On Time 시간 (단위: seconds) (1 ~ 8. PH 마다 LED 4) */
	UINT8				sequencer_state[MAX_PH][3];							/* Sequencer State. [0] : seq_cmd (0x00:run, 0x01:Reset, 0x02:Unused), [1] (0x00:Disable, 0x01:Enable), [2] valid_cmd (0x01: Valid command request, 0x00: invalid command requent */

	UINT16				get_last_received_record_id;						/* 가장 최근에 수신된 Record ID 값 임시 저장 */
	UINT16				get_last_received_reply_error;						/* 가장 최근에 수신된 응답 에러 값 */

	UINT16				focus_position[MAX_PH];								/* Range: 21284 - 44252, where 32768 is theoretical middle. 1 unit = 0.174um (기준: Luxbeam 4800/9500) */
	UINT16				auto_focus_position[MAX_PH];						/* Range: 21284 - 44252, where 32768 is theoretical middle. 1 unit = 0.174um (기준: Luxbeam 4800/9500) */
	UINT16				focus_motor_status[MAX_PH];							/* Motor Status (1 ~ 8) */
	UINT16				light_source_driver_amplitude[MAX_PH][MAX_LED];		/* LED Power Value (1 ~ 8. PH 마다 LED 4) (0x0000 (0) ~ 0x0fff (4095) */
	UINT16				light_source_driver_temp_led[MAX_PH][MAX_LED];		/* LED Temperature (1 ~ 8. PH 마다 LED 4). 나누기 10을 하면 실제 온도 값 */
	UINT16				light_source_driver_temp_board[MAX_PH][MAX_LED];	/* Board Temperature (1 ~ 8. PH 마다 LED 4). 나누기 10을 하면 실제 온도 값 */
	UINT32				light_source_on_time_counter[MAX_PH][MAX_LED];		/* LED On Time 시간 (단위: seconds) (1 ~ 8. PH 마다 LED 4) */
	UINT32				overall_error_status_word[MAX_PH];					/* LUT 48000 이상만 (이하는 지원하지 않음) */
	UINT32				focus_motor_move_abs_position[MAX_PH];				/* Motor Position (63000 - 85000) (1 ~ 8) (단위: um)*/
																			/* RLT 4600_4700 모델만 Status2 필드 값 사용 */
	UINT32				light_source_driver_status[MAX_PH][MAX_LED];		/* LED Driver의 상태 값 */

	/*
	 desc : Check the PH and LED numbers
	 parm : ph_no	- [in]  PH Number (0x01 ~ 0x08)
			led_no	- [in]  LED Number (1:365, 2:385, 3:395, 4:405)
	 retn : TRUE or FALSE
	*/
	BOOL IsValidNoPHLED(UINT8 ph_no, ENG_LLPI led_no)
	{
		if (ph_no < 0x01 || ph_no > MAX_PH)	return FALSE;
		if (led_no == ENG_LLPI::en_all || led_no == ENG_LLPI::en_zero)	return FALSE;
		return TRUE;
	}

	/*
	 desc : Check whether it is in SPOT mode
	 parm : ph_no	- [in]  Photohead Number (1 based)
	 retn : TRUE or FALSE
	*/
	BOOL IsSpotMode(UINT8 ph_no)
	{
		if (ph_no < 0x01 || ph_no > MAX_PH)	return FALSE;

		return (0x02 == load_internal_image[ph_no-1] && 0x01 == active_sequence_file[ph_no-1] &&
				0x00 == enable_flatness_correction_mask[ph_no-1] && 0x00 == dmd_mirror_shake[ph_no-1]);
	}

	/*
	 desc : 강제로 모든 Photohead의 Z Axis 모터가 초기화 내지 혹은 초기화되지 않았다고 설정
	 parm : ph_cnt	- [in]  설정 대상인 Photohead Count
			init	- [in]  FALSE (초기화 안되었다고...), TRUE (초기화 되었다고)
	 retn : None
	*/
	VOID SetAllMotorInited(UINT8 ph_count, BOOL init)
	{
		/* 초기화 안되었다고 설정 */
		if (!init)
		{
			switch (ph_count)
			{
			case 0x08	:	focus_motor_status[4] |= 0x0002;	/* 0000 0000 0000 0010 */
			case 0x07	:	focus_motor_status[4] |= 0x0002;	/* 0000 0000 0000 0010 */
			case 0x06	:	focus_motor_status[4] |= 0x0002;	/* 0000 0000 0000 0010 */
			case 0x05	:	focus_motor_status[4] |= 0x0002;	/* 0000 0000 0000 0010 */
			case 0x04	:	focus_motor_status[3] |= 0x0002;	/* 0000 0000 0000 0010 */
			case 0x03	:	focus_motor_status[2] |= 0x0002;	/* 0000 0000 0000 0010 */
			case 0x02	:	focus_motor_status[1] |= 0x0002;	/* 0000 0000 0000 0010 */
			case 0x01	:	focus_motor_status[0] |= 0x0002;	/* 0000 0000 0000 0010 */
			}
		}
		/* 초기화 되었다고 설정 */
		else
		{
			switch (ph_count)
			{
			case 0x08	:	focus_motor_status[4] &= 0xfffd;	/* ffff ffff ffff 1101 */
			case 0x07	:	focus_motor_status[4] &= 0xfffd;	/* ffff ffff ffff 1101 */
			case 0x06	:	focus_motor_status[4] &= 0xfffd;	/* ffff ffff ffff 1101 */
			case 0x05	:	focus_motor_status[4] &= 0xfffd;	/* ffff ffff ffff 1101 */
			case 0x04	:	focus_motor_status[3] &= 0xfffd;	/* ffff ffff ffff 1101 */
			case 0x03	:	focus_motor_status[2] &= 0xfffd;	/* ffff ffff ffff 1101 */
			case 0x02	:	focus_motor_status[1] &= 0xfffd;	/* ffff ffff ffff 1101 */
			case 0x01	:	focus_motor_status[0] &= 0xfffd;	/* ffff ffff ffff 1101 */
			}
		}
	}

	/*
	 desc : 모든 Photohead의 Motor Status가 초기화 되었는지 여부
	 parm : ph_cnt	- [in]  검사 대상인 Photohead Count
	 retn : TRUE (초기화 완료된 상태) or FALSE (아직 초기화 되지 않은 상태)
	 note : 모두 중앙으로 이동이 되었는지만 체크
	*/
	BOOL IsAllMotorMiddleInited(UINT8 ph_cnt)
	{
#if 0
		switch (ph_count)
		{
		case 0x08	:	if ((focus_motor_status[7] & 0x000b) != 0x0000)	return FALSE;
		case 0x07	:	if ((focus_motor_status[6] & 0x000b) != 0x0000)	return FALSE;
		case 0x06	:	if ((focus_motor_status[5] & 0x000b) != 0x0000)	return FALSE;
		case 0x05	:	if ((focus_motor_status[4] & 0x000b) != 0x0000)	return FALSE;
		case 0x04	:	if ((focus_motor_status[3] & 0x000b) != 0x0000)	return FALSE;
		case 0x03	:	if ((focus_motor_status[2] & 0x000b) != 0x0000)	return FALSE;
		case 0x02	:	if ((focus_motor_status[1] & 0x000b) != 0x0000)	return FALSE;
		case 0x01	:	if ((focus_motor_status[0] & 0x000b) != 0x0000)	return FALSE;
		}
#else
		if (ph_cnt < 0x01 || ph_cnt > MAX_PH)	return FALSE;
		for (INT i=(INT8)(ph_cnt-1); i>=0x00; i--)
		{
			/* Check point: mid_pos_proc_running (3:1) must_move_to_mid_pos (1:1) busy_moving (0:1) */
			/* 1011 : 0x0b : 위의 값 중 하나라도 1 값이 존재하면 초기화 안된 상태 입니다. */
			if ((focus_motor_status[i] & 0x000b) != 0x0000)	return FALSE;
		}
#endif
		return TRUE;
	}

	/*
	 desc : 모든 Photohead의 Motor Status가 초기화 되었는지 여부
	 parm : ph_no	- [in]  검사 대상인 Photohead Index (1 or Later)
	 retn : TRUE (초기화 완료된 상태) or FALSE (아직 초기화 되지 않은 상태)
	 note : 모두 중앙으로 이동이 되었는지만 체크
	*/
	BOOL IsMotorMiddleInited(UINT8 ph_no)
	{
		if (ph_no < 0x01 || ph_no > MAX_PH)	return FALSE;
		return ((focus_motor_status[ph_no-1] & 0x000b) != 0x0000) ? FALSE : TRUE;
	}

	/*
	 desc : PH 내에 온도가 가장 높은 LED와 Board의 온도 값 반환
	 parm : ph_no		- [in]  Photohead Number (1 or Later)
			temp_led	- [out] 가장 높은 LED 온도 (4개 LED 중)
			temp_bd		- [out] 가장 높은 Board 온도 (4개 LED Board 중)
	 retn : None
	*/
	VOID GetMaxTempLedBD(UINT8 ph_no, UINT16 &temp_led, UINT16 &temp_bd)
	{
		UINT8 i	= 0x00;

		/* 값 초기화 */
		temp_led= 0x0000;
		temp_bd	= 0x0000;
		if (ph_no < 0x01 || ph_no > MAX_PH)	return;

		for (; i<0x04; i++)
		{
			if (temp_led <= light_source_driver_temp_led[ph_no-1][i])
			{
				temp_led = light_source_driver_temp_led[ph_no-1][i];
			}
			if (temp_bd <= light_source_driver_temp_board[ph_no-1][i])
			{
				temp_bd = light_source_driver_temp_board[ph_no-1][i];
			}
		}
	}

	/*
	 desc : PH 내에 온도가 가장 낮은 LED와 Board의 온도 값 반환
	 parm : ph_no		- [in]  Photohead Number (1 or Later)
			temp_led	- [out] 가장 높은 LED 온도 (4개 LED 중)
			temp_bd		- [out] 가장 높은 Board 온도 (4개 LED Board 중)
	 retn : None
	*/
	VOID GetMinTempLedBD(UINT8 ph_no, UINT16 &temp_led, UINT16 &temp_bd)
	{
		UINT8 i	= 0x00;

		/* 값 초기화 */
		temp_led= UINT16_MAX;
		temp_bd	= UINT16_MAX;
		if (ph_no >= MAX_PH)	return;

		for (; i<0x04; i++)
		{
			if (temp_led > light_source_driver_temp_led[ph_no-1][i])
			{
				temp_led = light_source_driver_temp_led[ph_no-1][i];
			}
			if (temp_bd > light_source_driver_temp_board[ph_no-1][i])
			{
				temp_bd = light_source_driver_temp_board[ph_no-1][i];
			}
		}
	}

	/*
	 desc : Check whether the photohead number is valid
	 parm : ph_no	- [in]  Photohead Number (0x01 ~ 0x08)
	 retn : TRUE or FALSE
	*/
	BOOL IsValidPhNo(UINT8 ph_no)	{	return (ph_no > 0x00 && ph_no <= MAX_PH);	}
	/*
	 desc : Check whether the led number is valid
	 parm : ph_no	- [in]  Led Number (0x01 ~ 0x04)
	 retn : TRUE or FALSE
	*/
	BOOL IsValidLedNo(ENG_LLPI led_no)	{	return (led_no >= ENG_LLPI::en_365nm && led_no <= ENG_LLPI::en_405nm);	}

	/*
	 desc : Get the led information of photohead
	 parm : ph_no	- [in]  Photohead Number (0x01 ~ 0x08)
			led_no	- [in]  Led number (0x01 ~ 0x04)
	 retn : TRUE or FALSE
	*/
	BOOL IsPhLedLightOn(UINT8 ph_no, ENG_LLPI led_no)	/* light on or off state */
	{
		if (!IsValidPhNo(ph_no) || !IsValidLedNo(led_no))	return FALSE;
		return light_source_driver_light_onoff[ph_no-1][UINT8(led_no)-1];
	}
	BOOL IsPhLedAmpIdxAll(UINT8 ph_no, UINT16 amp)	/* Amplitude Index (0 ~ 4095) */
	{
		if (!IsValidPhNo(ph_no))	return FALSE;
		return (light_source_driver_amplitude[ph_no-1][0] == 0x0000 &&
				light_source_driver_amplitude[ph_no-1][1] == 0x0000 &&
				light_source_driver_amplitude[ph_no-1][2] == 0x0000 &&
				light_source_driver_amplitude[ph_no-1][3] == 0x0000);
	}
	BOOL IsPhLedAmpIdxEmpty(UINT8 ph_no)
	{
		if (!IsValidPhNo(ph_no))	return FALSE;
		return (light_source_driver_amplitude[ph_no-1][0] +
				light_source_driver_amplitude[ph_no-1][1] +
				light_source_driver_amplitude[ph_no-1][2] +
				light_source_driver_amplitude[ph_no-1][3]) == 0;
	}
	UINT16 GetPhLedAmpIdx(UINT8 ph_no, ENG_LLPI led_no)	/* Amplitude Index (0 ~ 4095) */
	{
		if (!IsValidPhNo(ph_no) || !IsValidLedNo(led_no))	return 0x0000;
		return light_source_driver_amplitude[ph_no-1][UINT8(led_no)-1];
	}
	UINT16 GetPhLedTempLed(UINT8 ph_no, ENG_LLPI led_no)	/* Led Temperature */
	{
		if (!IsValidPhNo(ph_no) || !IsValidLedNo(led_no))	return 0x0000;
		return light_source_driver_temp_led[ph_no-1][UINT8(led_no)-1];
	}
	UINT16 GetPhLedTempBoard(UINT8 ph_no, ENG_LLPI led_no)	/* Board Temperature */
	{
		if (!IsValidPhNo(ph_no) || !IsValidLedNo(led_no))	return 0x0000;
		return light_source_driver_temp_board[ph_no-1][UINT8(led_no)-1];
	}
	UINT32 GetPhLedTimeCount(UINT8 ph_no, ENG_LLPI led_no)	/* Time Count */
	{
		if (!IsValidPhNo(ph_no) || !IsValidLedNo(led_no))	return 0x00000000;
		return light_source_on_time_counter[ph_no-1][UINT8(led_no)-1];
	}

}	STG_LDDP,	*LPG_LDDP;

/* --------------------------------------------------------------------------------------------- */
/*                     Shared Memory 구조체 - Luria Comm Management (0xA05)                      */
/* --------------------------------------------------------------------------------------------- */

typedef struct __st_luria_data_comm_management__
{
	UINT8				server_ip[4];		/* Announce Server Ip Addr (The IP address of the UI (announce server) that the Luria (announce client) will send announcements to) */
	UINT8				announce_status;	/* 1:Enabled, 0:Disabled (The announcements will be automatically disabled by Luria if no announcements could be sent three times in a row) */

}	STG_LDCM,	*LPG_LDCM;

/* --------------------------------------------------------------------------------------------- */
/*                            Shared Memory 구조체 - System (0xA07)                              */
/* --------------------------------------------------------------------------------------------- */

/* SSDSmartEntry of System (0xA7) */
typedef struct __st_luria_system_ssd_entry__
{
	UINT8				id;
	UINT8				flag;
	UINT8				pad1;
	UINT8				worst_value;
	UINT32				data;
	UINT8				attrib;
	UINT8				pad2;
	UINT8				threadhold;

	/* 2 or 4 bytes Big or Little endian */
	VOID SWAP()
	{
		data	= SWAP32(data);
	}

}	STG_LSSE,	*LPG_LSSE;

/* SSDSmartData of System (0xA7) */
typedef struct __st_luria_system_ssd_data__
{
	UINT8				ssd_no;
	UINT8				read_ok;

	STG_LSSE			data[MAX_SSD_SMART_DATA];	/* fixed. 14 ea */

	/* 2 or 4 bytes Big or Little endian */
	VOID SWAP()
	{
		for (UINT8 i=0; i<MAX_SSD_SMART_DATA; i++)	data[i].SWAP();
	}

}	STG_LSSD,	*LPG_LSSD;

/* Luria Config - System Status (0xA7) (version 2.3.0 or Later (Newer) 기준) */
typedef struct __st_luria_data_system_status__
{
	UINT8				ph_load_internal_test_img_num[MAX_PH];	/* This will load the selected test image that is built-in the photo head and display it on the DMD */
	UINT16				ph_mainboard_temp[MAX_PH];				/* Photohead 8개의 Mainboard Temperature (실제 값은 나누기 10을 해줘야 됨) */
																/* 이 값이 만약 50도 이상 넘으면, Photohead 내에 냉각이 정상적으로 동작되지 않음 */
	UINT32				get_overall_error_status_multi[MAX_PH];	/* Photohead의 전반적인 에러 상태 값 */
	UINT32				get_system_status[3];					/* 0th: Motor controller status bit (0: Normal) */
																/* 1th: Photo head status bit (0: Normal) */
																/* 2th: Luria PC status bit (0: Normal) */
	
	STG_LSSD			get_smart_data[MAX_PH];					/* 포토헤드 개수만큼 SSD 정보 */

	/*
	 desc : 에러 발생 여부
	 parm : ph_no	- [in]  1 ~ 8 (Max 8)
	 retn : TRUE (Error) or FALSE (Normal)
	*/
	BOOL IsErrorAll()
	{
		return (get_system_status[0]+get_system_status[1]+get_system_status[2]) > 0 ? TRUE : FALSE;
	}
	BOOL IsErrorPH()
	{
		return get_system_status[1] > 0 ? TRUE : FALSE;
	}
	BOOL IsErrorPH(UINT8 ph_no)
	{
		UINT32 u32Mask1	= 0x00000001 << (ph_no-1);
		UINT32 u32Mask2	= 0x00000001 << (ph_no-1+0x08);
		if ((get_system_status[1] & u32Mask1) != 0x00 ||
			(get_system_status[1] & u32Mask2) != 0x00)	return TRUE;	/* There is an error */
		return FALSE;
	}
	BOOL IsInitedPH(UINT8 ph_no)
	{
		UINT32 u32Mask	= 0x00000001 << (ph_no-1);
		if ((get_system_status[1] & u32Mask) == 0x00)	return TRUE;	/* Normal */
		return FALSE;	/* Error */
	}
	BOOL IsCommSuccPH(UINT8 ph_no)
	{
		UINT32 u32Mask	= 0x00000001 << (ph_no-1+0x08);
		if ((get_system_status[1] & u32Mask) == 0x00)	return TRUE;	/* Normal */
		return FALSE;	/* Error */
	}
	BOOL IsErrorPC()
	{
		return get_system_status[2] > 0 ? TRUE : FALSE;
	}

	/*
	 desc : 초기화 (값을 모두 0xff로 초기화)
	 parm : None
	 retn : None
	*/
	VOID ResetStatus()
	{
		memset(get_system_status, 0xff, sizeof(UINT32) * 3);
	}

	/*
	 desc : Check whether the focus motors of all photohead z-axis are initialized
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsAllPHInited()
	{
		return get_system_status[2] == 0x00000000 ? TRUE : FALSE;
	}

}	STG_LDSS,	*LPG_LDSS;

/* Luria Config - Focus (0xA8) (version 2.3.0 or Later 기준) */
typedef struct __st_luria_data_ph_focus__
{
	UINT8				initialized:1;				/* 0x00 : Not initialize, 0x01 : Initialized */
	UINT8				aaq_actived:1;				/* 0x00 : Disable AAQ, 0x01 : Enable AAQ (Active Area Qualifier) */
	UINT8				af_edge_trig:1;				/* 0x00 : Edge Trigger Disabled, 0x01 : Enabled */
	UINT8				u8_bit_reserved:5;
	UINT8				auto_focus[MAX_PH];			/* Photohead 별로 Auto Focus에 대해 Enable 여부 */

	UINT16				af_gain;					/* Gain/damping factor (Valid range 1 ~ 4095) */
	UINT16				af_edge_trig_dist;			/* The max distance below or above current AF set-point that AF will be active (um) */

	INT32				z_pos[MAX_PH];				/* Z-position (unit: nm) */
	INT32				trim[MAX_PH];				/* Focus trim (unit: nm) */
	INT32				abs_work_range_min[MAX_PH];	/* The min absolute focus position that the AF will operate within (um) */
	INT32				abs_work_range_max[MAX_PH];	/* The max absolute focus position that the AF will operate within (um) */

	UINT32				abs_work_range_status;		/* Status word giving status of autofocus absolute work range */
	UINT32				aaq_start_end[2];			/* Distance from exposure start/end where AF is inactive. (um) (index=0 : start, index=1 : end) */
	UINT32				out_dof_trig_pulse[MAX_PH];	/* Reports the number of trigger pulses that autofocus position has been outside the given DOF (MachineConfig:DepthOfFocus) */

	/*
	 desc : Abs Work Range Status 정보 반환 (최소 혹은 최대 노광 범위를 벗어났는지 여부)
	 parm : ph_no	- [in]  Photohead Number (1-based. Max 7)
			type	- [in]  최소 혹은 최대 값을 벗어났는지 여부 즉, 0 : below_min, 1 : above max
	 retn : TRUE or FALSE
	*/
	BOOL IsWorkRangeStatusValid(UINT8 ph_no, UINT8 type)
	{
		if (ph_no < 0x01 || ph_no > MAX_PH)	return FALSE;
		return (abs_work_range_status & (0x00000001 << ((ph_no - 0x01) + MAX_PH * type))) > 0;
	}

	/*
	 desc : Initializes the position of the photoheads z-axis
	 parm : None
	 retn : None
	*/
	VOID ResetAllPhZAxisPos(INT32 pos=-1)
	{
		for (UINT8 i=0x00; i<MAX_PH; i++)	z_pos[i]	= pos;
	}

}	STG_LDPF,	*LPG_LDPF;

/* Luria Shared Memory - All */
typedef struct __st_luria_data_shared_memory__
{
	UINT8				last_send_fid;	/* 가장 마지막에 송신한 명령어의 Family ID */
	UINT8				last_send_uid;	/* 가장 마지막에 송신한 명령어의 User ID */
	UINT8				pkt_cmd[MAX_CMD_FAMILY_ID][MAX_CMD_USER_ID];
	STG_LDMC			machine;		/* FamilyId : 0xA0 */
	STG_LDJM			jobmgt;			/* FamilyId : 0xA1 */
	STG_LDPP			panel;			/* FamilyId : 0xA2 */
	STG_LDEW			exposure;		/* FamilyId : 0xA3 */
	STG_LDDP			directph;		/* FamilyId : 0xA4 */
	STG_LDCM			commmgt;		/* FamilyId : 0xA5 */
	STG_LDSS			system;			/* FamilyId : 0xA7 */
	STG_LDPF			focus;			/* FamilyId : 0xA8 */

	STG_DLSM			link;			/* 통신 상태 */

	/*
	 desc : Reset Last Command
	 parm : None
	 retn : None
	*/
	VOID ResetLastRecvCmd()
	{
		last_send_fid	= 0x00;
		last_send_uid	= 0x00;
	}

	/*
	 desc : 가장 최근에 수신된 패킷 명령어 설정
	 parm : f_id	- [in]  Family ID (0xA0 ~ 0xA9)
			u_id	- [in]  User ID (0x01 ~ 0xff)
	 retn : None
	*/
	VOID RecvCMD(UINT8 f_id, UINT8 u_id)
	{
		UINT8 u8Idx	= f_id - (UINT8)ENG_LUDF::en_machine_config;
		/* 최근에 패킷이 수신되었다라고 플래그 설정 */
		pkt_cmd[u8Idx][u_id]	= 0x01;
	}

	/*
	 desc : 가장 최근에 송신된 패킷 명령어 설정
	 parm : f_id	- [in]  Family ID (0xA0 ~ 0xA9)
			u_id	- [in]  User ID (0x01 ~ 0xff)
	 retn : None
	*/
	VOID SendCMD(UINT8 f_id, UINT8 u_id)
	{
		UINT8 u8Idx	= f_id - (UINT8)ENG_LUDF::en_machine_config;
		/* 가장 최근에 송신 명령어 정보 설정 */
		last_send_fid	= f_id;
		last_send_uid	= u_id;
		/* 최근에 패킷이 송신되었다라고 플래그 설정 */
		pkt_cmd[u8Idx][u_id]	= 0x00;
	}

	/*
	 desc : 최근에 수신된 패킷이 있는지 확인
	 parm : f_id	- [in]  Family ID (0xA0 ~ 0xA9)
			u_id	- [in]  User ID (0x01 ~ 0xff)
	 retn : TRUE or FALSE
	*/
	BOOL IsRecvCmd(UINT8 f_id, UINT8 u_id)
	{
		UINT8 u8Idx	= f_id - (UINT8)ENG_LUDF::en_machine_config;
		return pkt_cmd[u8Idx][u_id] > 0x00 ? TRUE : FALSE;
	}
	/* System (0xA7) */
	BOOL IsRecvCmdHWInited()			{	return IsRecvCmd(UINT8(ENG_LUDF::en_system), UINT8(ENG_LCSS::en_initialize_hardware));			}
	BOOL IsRecvCmdLoadedInternalImage()	{	return IsRecvCmd(UINT8(ENG_LUDF::en_system), UINT8(ENG_LCSS::en_load_internal_test_image));	}
	BOOL IsRecvCmdSetLedPower()			{	return IsRecvCmd(UINT8(ENG_LUDF::en_system), UINT8(ENG_LCSS::en_set_light_intensity));		}
	/*
	 설명 : 모든 광학계의 높이가 동일한지 여부
	 변수 : ph_cnt	- [in]  포토헤드 개수
	 반환 : None
	*/
	BOOL IsAllEqualPHZAxis(UINT8 ph_cnt)
	{
		UINT32 u32Pos	= directph.focus_motor_move_abs_position[0];
		for (UINT8 i=1; i<ph_cnt; i++)
		{
			if (u32Pos != directph.focus_motor_move_abs_position[i])	return FALSE;
		}
		return TRUE;
	}

	/*
	 desc : 가장 마지막 (최근)에 수신된 명령어 응답 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsLastRecvCmd()
	{
		if (0x00 == last_send_fid || 0x00 == last_send_uid)	return FALSE;
		return pkt_cmd[last_send_fid - (UINT8)ENG_LUDF::en_machine_config][last_send_uid] > 0x00 ? TRUE : FALSE;
	}

}	STG_LDSM,	*LPG_LDSM;

#pragma pack (pop)	// 1 bytes

#pragma pack (push, 8)

/* Dynamic Panel Data */
typedef struct __st_xml_dynamic_panel_data__
{
	UINT8				inverse:1;			/* 0 : FALSE, 1 : TRUE */
	UINT8				content:2;			/* 0 : Serial Number, 1 : Scale Info, 2 : General Text */
	UINT8				type:2;				/* 0 : normal, 1 : QR Code, 2: DC Code */
	UINT8				u8_bit_reserved:3;
	UINT8				field_cnt;			/* D Code 하위에 존재하는 Field 좌표 정보 개수 (최대 255) */
	UINT8				u8_reserved[5];

	UINT16				d_code;
	UINT16				rotation:9;			/* Rotation Angle (Degree) */
	UINT16				u16_bit_reserved:7;
	UINT16				u16_reserved[2];

	UINT32				size_x;				/* Field Size. Horizontal*/
	UINT32				size_y;				/* Field Size. Vertical*/

	/*
	 desc : 값 설정 여부
	 parm : None
	 retn : TRUE or FALSE
	*/
	BOOL IsValid()
	{
		return (d_code > 0 && size_x > 0 && size_y > 0 && field_cnt > 0) ? TRUE : FALSE;
	}

}	STG_XDPD,	*LPG_XDPD;

enum STG_XMXY_RESERVE_FLAG : UINT32
{
	GLOBAL =    0b0000000000000000000000000000000000000001,
	LOCAL =     0b0000000000000000000000000000000000000010,
	RESERVE1 =  0b0000000000000000000000000000000000000100,
	RESERVE2 =  0b0000000000000000000000000000000000001000,
	RESERVE3 =  0b0000000000000000000000000000000000010000,
	RESERVE4 =  0b0000000000000000000000000000000000100000,
	RESERVE5 =  0b0000000000000000000000000000000001000000,
	RESERVE6 =  0b0000000000000000000000000000000010000000,
	RESERVE7 =  0b0000000000000000000000000000000100000000,
	RESERVE8 =  0b0000000000000000000000000000001000000000,
	RESERVE9 =  0b0000000000000000000000000000010000000000,
	RESERVE10 = 0b0000000000000000000000000000100000000000,
	RESERVE11 = 0b0000000000000000000000000001000000000000,
	RESERVE12 = 0b0000000000000000000000000010000000000000,
	RESERVE13 = 0b0000000000000000000000000100000000000000,
	USED =      0b0000000000000000000000001000000000000000,
};

/* XML에서 읽어들인 마크 구성 정보 */
typedef struct __st_xml_mark_x_y__
{
	UINT32				org_id;		/* Sorting 이전에 저장된 메모리 저장 위치 (XML 파일로부터 읽어들인 순서) */
	UINT32				tgt_id;		/* Sorting 이후에 저장된 메모리 저장 위치 (얼라인 마크 검사를 위한 순서) */
	DOUBLE				mark_x;		/* 단위: mm */
	DOUBLE				mark_y;		/* 단위: mm */
	UINT32				reserve;    //리저브


	std::tuple<double, double> GetMarkPos() 
	{
		return std::make_tuple(mark_x, mark_y);
	}

	void ClearFlag() { reserve = 0;}

	void SetFlag(STG_XMXY_RESERVE_FLAG flag)
	{
		reserve |= flag;
	}

	bool GetFlag(STG_XMXY_RESERVE_FLAG flag)
	{
		return (reserve & flag) != 0;
	}

	STG_XMXY()
	{
		this->mark_x = 0;
		this->mark_y = 0;

		this->org_id=0;
		this->tgt_id = 0;
		
		this->reserve = 0;
	}

	STG_XMXY(double markX, double markY)
	{
		this->mark_x = markX;
		this->mark_y = markY;

		this->org_id = 0;
		this->tgt_id = 0;

		this->reserve = 0;
	}

}	STG_XMXY,	*LPG_XMXY;

typedef struct __st_mark_info__
{
	__st_mark_info__()
	{
		ZeroMemory(this, sizeof(*this));
	}

	int		nResult;
	double	dOffsetX;
	double	dOffsetY;
	double	dScore;

}	STG_MARK_INFO, * LPG_MARK_INFO;

typedef struct __st_mark_x_y_ex__
{
	__st_mark_x_y_ex__()
	{
		ZeroMemory(this, sizeof(*this));
		stInfo.dScore = -1;
	}

	STG_MARK_INFO	stInfo;
	CRect			rtArea;
	STG_XMXY		stMark;
	
}	STG_MARK, * LPG_MARK;

#pragma pack (pop)	/* 8 bytes order */