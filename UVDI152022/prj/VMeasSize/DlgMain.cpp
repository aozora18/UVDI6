
/*
 desc : Main Dialog
*/

#include "pch.h"
#include "MainApp.h"
#include "DlgMain.h"

#include "MainThread.h"
#include "DlgIVal.h"

#define ONE_SCAN_WIDTH	20.6f	/* unit : mm */

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*
 desc : Constructor
 parm : The parent's object
 retn : None
*/
CDlgMain::CDlgMain(CWnd* parent /*=NULL*/)
	: CMyDialog(CDlgMain::IDD, parent)
{
	m_bDrawBG		= 0x01;
	m_hIcon			= AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_u8ViewMode	= 0x00;
	m_pMainThread	= NULL;
	m_bSetThick		= FALSE;
	m_u8GrabbedMode	= 0x00;
	m_pGridResult	= NULL;
	m_pDlgIVal		= NULL;
}

/*
 desc : Dialog Data Exchange Function
 parm : dx	- DataExchange Object
 retn : None
*/
VOID CDlgMain::DoDataExchange(CDataExchange* dx)
{
	CMyDialog::DoDataExchange(dx);

	UINT32 i, u32StartID;
	/* group box */
	u32StartID	= IDC_MAIN_GRP_VIEW;
	for (i=0; i<8; i++)		DDX_Control(dx, u32StartID+i,	m_grp_ctl[i]);
	/* For Image */
	u32StartID	= IDC_MAIN_PIC_VIEW;
	for (i=0; i<1; i++)		DDX_Control(dx, u32StartID+i,	m_pic_ctl[i]);
	/* Check - Normal */
	u32StartID	= IDC_MAIN_CHK_MC2_DRV_0;
	for (i=0; i<10; i++)	DDX_Control(dx, u32StartID+i,	m_chk_ctl[i]);
	/* Button - Normal */
	u32StartID	= IDC_MAIN_BTN_EXIT;
	for (i=0; i<13; i++)	DDX_Control(dx, u32StartID+i,	m_btn_ctl[i]);
	/* Static - Normal */
	u32StartID	= IDC_MAIN_TXT_MC2_MOVE;
	for (i=0; i<12; i++)	DDX_Control(dx, u32StartID+i,	m_txt_ctl[i]);
	/* edit - float */
	u32StartID	= IDC_MAIN_EDT_MC2_DIST;
	for (i=0; i<8; i++)		DDX_Control(dx, u32StartID+i,	m_edt_flt[i]);
	/* Edit - integer */
	u32StartID	= IDC_MAIN_EDT_GRAB_WIDTH;
	for (i=0; i<3; i++)		DDX_Control(dx, u32StartID+i,	m_edt_int[i]);
}

BEGIN_MESSAGE_MAP(CDlgMain, CMyDialog)
	ON_MESSAGE(WM_MAIN_THREAD,	OnMsgMainThread)
	ON_MESSAGE(WM_MSG_DIALOG_IVAL, OnMsgDialog)
	ON_WM_LBUTTONDOWN()
	ON_WM_SYSCOMMAND()
 	ON_CONTROL_RANGE(BN_CLICKED, IDC_MAIN_BTN_EXIT, IDC_MAIN_BTN_IMAGE_GRAB,				OnBtnClick)
 	ON_CONTROL_RANGE(BN_CLICKED, IDC_MAIN_CHK_MC2_DRV_0, IDC_MAIN_CHK_ACAM_NO,				OnChkClick)
	ON_NOTIFY_RANGE(GVN_COLUMNCLICK, IDC_MAIN_GRID_MEAS_OPTION, IDC_MAIN_GRID_MEAS_OPTION,	OnGridColumnClick)
END_MESSAGE_MAP()

/*
 desc : Intercepts event messages generated by the system
 parm : id		- Event ID
		lparam	- Event data
 retn : 1 - Succeeded / 0 - Failed
*/
VOID CDlgMain::OnSysCommand(UINT32 id, LPARAM lparam)
{
//	switch (id)
//	{
//	}

	CMyDialog::OnSysCommand(id, lparam);
}

/*
 desc : Called first when the app is start
 parm : None
 retn : TRUE or FALSE
*/
BOOL CDlgMain::OnInitDlg()
{
	UINT32 u32Size	= 0, i = 0;

	/* 라이브러리 초기화 */
	if (!InitLib())		return FALSE;

	/* Initialize the controls */
	InitCtrl();
	InitGridResult();
	InitGridOption();
	LoadDefault();

	/* Creates the main thread */
	m_pMainThread	= new CMainThread(m_hWnd);
	ASSERT(m_pMainThread);
	if (!m_pMainThread->CreateThread(0, NULL, 100/*NORMAL_THREAD_SPEED*/))
	{
		delete m_pMainThread;
		m_pMainThread	= NULL;
	}
	/* Align Camera is the hole measurement mode */
	uvEng_Camera_SetCamMode(ENG_VCCM::en_hole_mode);

	return TRUE;
}

/*
 desc : Called last when the app is stopped
 parm : None
 retn : None
*/
VOID CDlgMain::OnExitDlg()
{
	/* Release the main thread */
	if (m_pMainThread)
	{
		m_pMainThread->Stop();
		while (m_pMainThread->IsBusy())	m_pMainThread->Sleep();
		delete m_pMainThread;
		m_pMainThread	= NULL;
	}
	/* Release the library */
	CloseLib();
	/* Release the memory of grid control */
	if (m_pGridResult)
	{
		m_pGridResult->DestroyWindow();
		delete m_pGridResult;
	}
	if (m_pGridOption)
	{
		m_pGridOption->DestroyWindow();
		delete m_pGridOption;
	}
	m_pGridResult	= NULL;
	m_pGridOption	= NULL;

	/* Destroy the existing child dialog */
	DestroyChild();
}

/*
 desc : 윈도 갱신될 때마다 호출됨
 parm : dc	- 윈도 DC
 retn : None
*/
VOID CDlgMain::OnPaintDlg(CDC *dc)
{
	RECT rDraw;

	if (0x01 == m_u8GrabbedMode)
	{
		STG_MSMP stParam	= {NULL};
		/* Get the image output area */
		m_pic_ctl[0].GetWindowRect(&rDraw);
		ScreenToClient(&rDraw);
		ApplyOption(stParam, FALSE);
		uvEng_Camera_DrawStripBitmap(dc->m_hDC, rDraw, GetCheckACam(), &stParam);
	}
	else if (0x02 == m_u8GrabbedMode)
	{
		/* Get the image output area */
		m_pic_ctl[0].GetClientRect(&rDraw);
		uvEng_Camera_DrawMBufID(m_pic_ctl[0].GetSafeHwnd(), rDraw, 0x01, 0x02);
	}
}

/*
 desc : 다이얼로그 크기가 변경될 경우... 각종 컨트롤 크기 변경
 parm : None
 retn : None
*/
VOID CDlgMain::OnResizeDlg()
{
}

/*
 desc : Library Init
 parm : None
 retn : TRUE or FALSE
*/
BOOL CDlgMain::InitLib()
{
	return uvEng_Init(ENG_ERVM::en_hole_size);
}

/*
 desc : Library Close
 parm : None
 retn : None
*/
VOID CDlgMain::CloseLib()
{
	uvEng_Close();
}

/*
 desc : 컨트롤 초기화
 parm : None
 retn : None
*/
VOID CDlgMain::InitCtrl()
{
	INT32 i;

	/* group box */
	for (i=0; i<8; i++)	m_grp_ctl[i].SetFont(&g_lf);

	/* text - normal */
	for (i=0; i<12; i++)
	{
		m_txt_ctl[i].SetTextFont(&g_lf);
		m_txt_ctl[i].SetDrawBg(1);
		m_txt_ctl[i].SetBaseProp(0, 1, 0, 0, RGB(254, 254, 254), 0, RGB(0, 0, 0));
	}
	/* button - normal */
	for (i=0; i<13; i++)
	{
		m_btn_ctl[i].SetLogFont(g_lf);
		m_btn_ctl[i].SetBgColor(g_clrBtnColor);
	}
	/* checkbox */
	for (i=0; i<10; i++)
	{
		m_chk_ctl[i].SetLogFont(g_lf);
		m_chk_ctl[i].SetBgColor(RGB(0xff, 0xff, 0xff));
	}
	m_chk_ctl[0].SetCheck(1);
	/* edit - integer */
	for (i=0; i<3; i++)
	{
		m_edt_int[i].SetEditFont(&g_lf);
		m_edt_int[i].SetBackColor(RGB(0xff, 0xff, 0xff));
		m_edt_int[i].SetTextColor(RGB(0x00, 0x00, 0x00));
		m_edt_int[i].SetInputType(ENM_DITM::en_int16);
		if (i < 2)
		{
			m_edt_int[i].SetReadOnly(TRUE);
			m_edt_int[i].SetMouseClick(FALSE);
		}
	}
	/* edit - float */
	for (i=0; i<8; i++)
	{
		m_edt_flt[i].SetEditFont(&g_lf);
		m_edt_flt[i].SetBackColor(RGB(0xff, 0xff, 0xff));
		m_edt_flt[i].SetTextColor(RGB(0x00, 0x00, 0x00));
		m_edt_flt[i].SetInputType(ENM_DITM::en_float);
		if (i > 3)
		{
			m_edt_flt[i].SetReadOnly(TRUE);
			m_edt_flt[i].SetMouseClick(FALSE);
		}
	}
}

/*
 desc : Create a grid control - result
 parm : None
 retn : None
*/
VOID CDlgMain::InitGridResult()
{
	TCHAR tzTitle[9][16]= { L"No", L"Stage.X", L"Stage.Y", L"ACam.X", L"Cent.X", L"Cent.Y",
							L"Angle", L"Size", L"Length" };
	INT32 i32Width[9]	= { 50, 85, 85, 85, 70, 72, 72, 72, 72 };
	UINT32 dwStyle		= WS_CHILD | WS_TABSTOP | WS_VISIBLE, i = 0, u32Cols = 9;

	GV_ITEM stGV = { NULL };
	CRect rGrid;

	// 현재 윈도 Client 크기
	m_grp_ctl[1].GetWindowRect(rGrid);
	ScreenToClient(rGrid);
	rGrid.left	+= 15;
	rGrid.right	-= 15;
	rGrid.top	+= 24;
	rGrid.bottom-= 15;

	/* Set the common properties of grid control */
	stGV.mask	= GVIF_TEXT | GVIF_FORMAT | GVIF_BKCLR | GVIF_FGCLR;
	stGV.crFgClr= RGB(32, 32, 32);
	/* Create a grid control */
	m_pGridResult	= new CGridCtrl;
	ASSERT(m_pGridResult);
	/* Set the style and scroll_bar of grid control */
	m_pGridResult->SetModifyStyleEx(WS_EX_STATICEDGE);
	m_pGridResult->SetDrawScrollBarVert(TRUE);
	m_pGridResult->SetDrawScrollBarHorz(FALSE);
	if (!m_pGridResult->Create(rGrid[i], this, IDC_MAIN_GRID_MEAS_RESULT, dwStyle))
	{
		delete m_pGridResult;
		m_pGridResult = NULL;
		return;
	}

	/* Set the output style of grid control */
	stGV.nFormat = DT_CENTER | DT_VCENTER | DT_SINGLELINE;
	stGV.crBkClr = RGB(214, 214, 214);
	stGV.crFgClr = RGB(0, 0, 0);

	/* Set the default values for grid control */
	m_pGridResult->SetLogFont(g_lf);
	m_pGridResult->SetRowCount(1);
	m_pGridResult->SetColumnCount(u32Cols);
	m_pGridResult->SetRowHeight(0, 25);
	m_pGridResult->SetBkColor(RGB(255, 255, 255));
	m_pGridResult->SetFixedColumnSelection(0);
	/* Set the title */
	for (i=0; i<u32Cols; i++)
	{
		stGV.row	= 0;
		stGV.col	= i;
		stGV.strText= tzTitle[i];
		m_pGridResult->SetItem(&stGV);
		m_pGridResult->SetColumnWidth(i, i32Width[i]);
	}

	m_pGridResult->SetBaseGridProp(1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0);
}

/*
 desc : Create a grid control - option
 parm : None
 retn : None
*/
VOID CDlgMain::InitGridOption()
{
	TCHAR tzTitle[2][16]= { L"Parameters", L"Values" };
	TCHAR tzRows[12][24]= { L"Orientation", L"Polarity (L)", L"Polarity (R)", 
							L"Box.Start.X (px)", L"Box.Start.Y (px)",
							L"Box.Size (W) (px)", L"Box.Size (H) (px)",
							L"Use Angle", L"Angle (°)", L"Interpolation",
							L"Edge Width (px)", L"Edge Offset (px)" };
	UINT32 dwStyle		= WS_CHILD | WS_TABSTOP | WS_VISIBLE, i = 0, u32Rows = 13;

	GV_ITEM stGV = { NULL };
	CRect rGrid;

	// 현재 윈도 Client 크기
	m_grp_ctl[2].GetWindowRect(rGrid);
	ScreenToClient(rGrid);
	rGrid.left	+= 15;
	rGrid.right	-= 15;
	rGrid.top	+= 24;
	rGrid.bottom-= 15;

	/* Set the common properties of grid control */
	stGV.mask	= GVIF_TEXT | GVIF_FORMAT | GVIF_BKCLR | GVIF_FGCLR;
	stGV.crFgClr= RGB(32, 32, 32);
	/* Create a grid control */
	m_pGridOption	= new CGridCtrl;
	ASSERT(m_pGridOption);
	/* Set the style and scroll_bar of grid control */
	m_pGridOption->SetModifyStyleEx(WS_EX_STATICEDGE);
	m_pGridOption->SetDrawScrollBarVert(FALSE);
	m_pGridOption->SetDrawScrollBarHorz(FALSE);
	if (!m_pGridOption->Create(rGrid[i], this, IDC_MAIN_GRID_MEAS_OPTION, dwStyle))
	{
		delete m_pGridOption;
		m_pGridOption = NULL;
		return;
	}

	/* Set the output style of grid control */
	stGV.nFormat = DT_CENTER | DT_VCENTER | DT_SINGLELINE;
	stGV.crBkClr = RGB(184, 184, 184);
	stGV.crFgClr = RGB(0, 0, 0);

	/* Set the default values for grid control */
	m_pGridOption->SetLogFont(g_lf);
	m_pGridOption->SetRowCount(u32Rows);
	m_pGridOption->SetColumnCount(2);
	m_pGridOption->SetRowHeight(0, 25);
	m_pGridOption->SetColumnWidth(0, 124);
	m_pGridOption->SetColumnWidth(1, 82);
	m_pGridOption->SetBkColor(RGB(255, 255, 255));
	m_pGridOption->SetFixedColumnSelection(0);
	/* Set the horizontal title */
	for (i=0; i<2; i++)
	{
		stGV.row	= 0;
		stGV.col	= i;
		stGV.strText= tzTitle[i];
		m_pGridOption->SetItem(&stGV);
	}
	/* Set the vertical title */
	stGV.nFormat = DT_LEFT | DT_VCENTER | DT_SINGLELINE;
	stGV.crBkClr = RGB(214, 214, 214);
	for (i=1; i<u32Rows; i++)
	{
		stGV.row	= i;
		stGV.col	= 0;
		stGV.strText= tzRows[i-1];
		m_pGridOption->SetItem(&stGV);
		m_pGridOption->SetRowHeight(i, 25);
	}
	/* Set the vertical values */
	stGV.nFormat = DT_CENTER | DT_VCENTER | DT_SINGLELINE;
	stGV.crBkClr = RGB(255, 255, 255);
	for (i=1; i<u32Rows; i++)
	{
		stGV.row	= i;
		stGV.col	= 1;
		stGV.strText= L"";
		m_pGridOption->SetItem(&stGV);
	}

	m_pGridOption->SetBaseGridProp(1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0);
}

/*
 desc : Updates the area of image (picture)
 parm : None
 retn : None
*/
VOID CDlgMain::InvalidateView()
{
	CRect rView;
	m_pic_ctl[0].GetWindowRect(rView);
	ScreenToClient(rView);
	InvalidateRect(rView, TRUE);
}

/*
 desc : The event of main thread
 parm : wparam	- [in]  Event ID
		lparam	- [in]  Event Data
 retn : 0L
*/
LRESULT CDlgMain::OnMsgMainThread(WPARAM wparam, LPARAM lparam)
{
	/* Called periodically */
	UpdatePeriod();
	/* Updates the Drive Position */
	UpdateDrvPos();
	/* Enable or disable controls*/
	EnableCtrl();

	return 0L;
}

/*
 desc : The event of child dialog
 parm : wparam	- [in]  Event ID
		lparam	- [in]  Event Data
 retn : 0L
*/
LRESULT CDlgMain::OnMsgDialog(WPARAM wparam, LPARAM lparam)
{
	TCHAR tzVal[32]	= {NULL};
	INT32 i32Item	= -1;

	if (0 == wparam)
	{
		m_pDlgIVal->DestroyWindow();
		delete m_pDlgIVal;
		m_pDlgIVal	= NULL;
	}
	else
	{
		i32Item	= m_pDlgIVal->GetItem();
		if (m_pDlgIVal->GetType() == 0x00)	swprintf_s(tzVal, 32, L"%I64d", m_pDlgIVal->GetValInt32());
		else								swprintf_s(tzVal, 32, L"%.4f", m_pDlgIVal->GetValDbl());
#if 0
		switch (i32Item)
		{
		case 4 : case 5 : case 6 : case 7 :	if (_wtoi64(tzVal) < 2)	return 0L;
		}
		if (i32Item == 4 || i32Item == 5)
		{
			swprintf_s(tzVal, 32, L"%I64d", _wtoi64(tzVal) - m_pGridOption->GetItemTextToInt(i32Item+2, 1) / 2);
		}
#endif
		m_pGridOption->SetItemText(i32Item, 1, tzVal);
		/* Update the grid control */
		m_pGridOption->Invalidate();
		/* Update the area of grabbed image */
		InvalidateView();
	}

	return 0L;
}

/*
 desc : Called periodically by the main thread
 parm : None
 retn : None
*/
VOID CDlgMain::UpdatePeriod()
{
	/* Grabbed Image Display */
	if (m_chk_ctl[8].GetCheck())	/* Live Mode */
	{
		UpdateLiveView();
		if (m_u8ViewMode == 0x00)	m_u8ViewMode	= 0x01;	/* Live Mode 저장 */
	}
}

/*
 desc : Update the position of various drives
 parm : None
 retn : TRUE or FALSE
*/
VOID CDlgMain::UpdateDrvPos()
{
	m_edt_flt[2].SetTextToNum(uvCmn_MCQ_GetACamCurrentPosZ(GetCheckACam()),		4, TRUE);
	m_edt_flt[3].SetTextToNum(uvCmn_MC2_GetDrvAbsPos(ENG_MMDI::en_stage_x),		4, TRUE);
	m_edt_flt[4].SetTextToNum(uvCmn_MC2_GetDrvAbsPos(ENG_MMDI::en_stage_y),		4, TRUE);
	m_edt_flt[5].SetTextToNum(uvCmn_MC2_GetDrvAbsPos(ENG_MMDI::en_align_cam1),	4, TRUE);
	m_edt_flt[6].SetTextToNum(uvCmn_MC2_GetDrvAbsPos(ENG_MMDI::en_align_cam2),	4, TRUE);
}

/*
 desc : Button event
 parm : id	- [in]  button id
 retn : None
*/
VOID CDlgMain::OnBtnClick(UINT32 id)
{
	switch (id)
	{
	case IDC_MAIN_BTN_EXIT			:	PostMessage(WM_CLOSE, 0, 0L);		break;

	case IDC_MAIN_BTN_MC2_MOVE_UP	:	MotionMove(ENG_MDMD::en_move_up);	break;
	case IDC_MAIN_BTN_MC2_MOVE_DN	:	MotionMove(ENG_MDMD::en_move_down);	break;
	case IDC_MAIN_BTN_ACAM_MOVE_UP	:	ZMotorMove(ENG_MDMD::en_move_up);	break;
	case IDC_MAIN_BTN_ACAM_MOVE_DN	:	ZMotorMove(ENG_MDMD::en_move_down);	break;
	case IDC_MAIN_BTN_MC2_RESET		:	MC2Recovery();						break;
	case IDC_MAIN_BTN_MOVE_UNLOAD	:	UnloadPosition();					break;
	case IDC_MAIN_BTN_RESULT_SAVE	:	SaveAsExcelFile();					break;
	case IDC_MAIN_BTN_RESULT_RESET	:	SetResultReset();					break;
	case IDC_MAIN_BTN_MOVE_NEXT		:	MotionNextMove();					break;
	case IDC_MAIN_BTN_THICK_DOF		:	SetDofFilmThick();					break;
	case IDC_MAIN_BTN_MEAS_MATCH	:	RunMeasMatch();						break;
	case IDC_MAIN_BTN_IMAGE_GRAB	:	GetGrabbedImage();					break;
	}
}

/*
 desc : Checkbox event
 parm : id	- [in]  checkbox id
 retn : None
*/
VOID CDlgMain::OnChkClick(UINT32 id)
{
	UINT8 i	= 0x00, u8ID = UINT8(id - IDC_MAIN_CHK_MC2_DRV_0);

	if (id >= IDC_MAIN_CHK_LIVE_VIEW)
	{
		switch (id)
		{
		case IDC_MAIN_CHK_LIVE_VIEW	:	SetLiveView();	break;
		case IDC_MAIN_CHK_ACAM_NO	:	ChangeACamNo();	break;
		}
	}
	else
	{
		for (; i<8; i++)	m_chk_ctl[i].SetCheck(0);
		m_chk_ctl[u8ID].SetCheck(1);
	}
}

/*
 desc : OnNotifyGridColumnClicked Event
 parm : id		- [in] Grid Control ID
		nmhdr	- [in] the handle and ID of the control sending the message and the notification code
		result	- [in]  A pointer to the LRESULT variable to store the result code if the message has been handled.
 retn : None
*/
VOID CDlgMain::OnGridColumnClick(UINT32 id, NMHDR *nmhdr, LRESULT *result)
{
	UINT8 u8Type;
	INT32 i32Row, i32Col=0, i32Val;
	NM_GRIDVIEW *pItem	= (NM_GRIDVIEW*)nmhdr;
	CString strVal;

	if (!pItem || m_u8GrabbedMode != 0x01)	return;

	/* Return the index of the selected row and column */
	i32Row	= pItem->iRow;
	i32Col	= pItem->iColumn;
	if (i32Row < 1 || i32Col < 1)	return;

	if (IDC_MAIN_GRID_MEAS_OPTION == id)
	{
		if (i32Row > 3 && i32Row < 8 || i32Row > 10 || i32Row == 9)
		{
			if (i32Row > 3 && i32Row < 8 || i32Row > 10)
			{
				u8Type	= 0x00;
				i32Val	= (INT32)m_pGridOption->GetItemTextToInt(i32Row, 1);
			}
			else if (i32Row == 9)
			{
				u8Type	= 0x01;
				i32Val	= (INT32)ROUNDED(m_pGridOption->GetItemTextToFloat(i32Row, 1) * 10000.0f, 0);
			}
			if (!m_pDlgIVal)
			{
				m_pDlgIVal	= new CDlgIVal(this);
				ASSERT(m_pDlgIVal);
				m_pDlgIVal->Create(u8Type, i32Row, i32Val);
				m_pDlgIVal->ShowWindow(SW_SHOW);
				m_pDlgIVal->CenterDialog(this);
			}
			else
			{
				m_pDlgIVal->SetValue(u8Type, i32Row, i32Val);
			}
		}
		else
		{
			strVal	= m_pGridOption->GetItemText(i32Row, 1);
			switch (i32Row)
			{
			case 1	:	if (0 == strVal.Compare(L"HORIZONTAL"))
							m_pGridOption->SetItemText(i32Row, 1, L"VERTICAL");
						else
							m_pGridOption->SetItemText(i32Row, 1, L"HORIZONTAL");	break;
			case 2	:
			case 3	:	if (0 == strVal.Compare(L"POSITIVE"))
							m_pGridOption->SetItemText(i32Row, 1, L"NEGATIVE");
						else
							m_pGridOption->SetItemText(i32Row, 1, L"POSITIVE");		break;
			case 8	:	if (0 == strVal.Compare(L"ENABLE"))
							m_pGridOption->SetItemText(i32Row, 1, L"DISABLE");
						else
							m_pGridOption->SetItemText(i32Row, 1, L"ENABLE");		break;
			case 10	:	if (0 == strVal.Compare(L"NEAREST"))
							m_pGridOption->SetItemText(i32Row, 1, L"BILINEAR");
						else if (0 == strVal.Compare(L"BILINEAR"))
							m_pGridOption->SetItemText(i32Row, 1, L"BICUBIC");
						else
							m_pGridOption->SetItemText(i32Row, 1, L"NEAREST");		break;
			}
		}
		m_pGridOption->InvalidateRowCol(i32Row, i32Col);
	}

	*result = 0;	/* fixed */
}

/*
 desc : Change the number of align camera
 parm : None
 retn : None
*/
VOID CDlgMain::ChangeACamNo()
{
	TCHAR tzNum[8]	= {NULL};
	m_chk_ctl[9].GetWindowText(tzNum, 8);
	if (0 == wcscmp(tzNum, L"1"))	m_chk_ctl[9].SetWindowText(L"2");
	else							m_chk_ctl[9].SetWindowText(L"1");
}

/*
 desc : Get the number of align camera
 parm : None
 retn : 1 or 2
*/
UINT8 CDlgMain::GetCheckACam()
{
	TCHAR tzNum[8]	= {NULL};
	m_chk_ctl[9].GetWindowText(tzNum, 8);
	return (UINT8)_wtoi(tzNum);
}

/*
 desc : Enable or disable Live Mode
 parm : None
 retn : None
*/
VOID CDlgMain::SetLiveView()
{
	UINT32 u32OnOff	= 0;
	UINT64 u64Tick	= 0;

	/* In Live View Mode */
	if (m_chk_ctl[8].GetCheck())
	{
		/* Align Camera is Live Mode */
		uvEng_Camera_SetCamMode(ENG_VCCM::en_live_mode);
		/* Trigger & Strobe : Enabled */
		if (uvEng_Trig_ReqTriggerStrobe(TRUE))
		{
			uvEng_Trig_ReqEncoderLive(GetCheckACam());
		}
	}
	else
	{
		/* Align Camera is the hole measurement mode */
		uvEng_Camera_SetCamMode(ENG_VCCM::en_hole_mode);

		/* Trigger & Strobe : Disabled */
		if (uvEng_Trig_ReqEncoderOutReset())
		{
			uvEng_Trig_ReqTriggerStrobe(FALSE);
			u64Tick = GetTickCount64();

			do	{

				/* Trigger Board로부터 설정에 대한 응답 값이 왔는지 확인 */
				if (0 == uvEng_ShMem_GetTrig()->enc_out_val)
				{
					/* 최대 1 초 동안 대기 후 루프 빠져나감 */
					if (GetTickCount64() > (u64Tick + 1000))	break;
				}
				else
				{
					/* 최대 2 초 동안 대기 후 응답 없으면, 루프 빠져나감 */
					if (GetTickCount64() > (u64Tick + 2000))	break;
				}
				Sleep(10);

			}	while (1);
		}
	}
	Invalidate(TRUE);
}

/*
 desc : Go to the next measurement position
 parm : None
 retn : None
*/
VOID CDlgMain::MotionNextMove()
{
	DOUBLE dbDist	= m_edt_flt[0].GetTextToDouble();
	DOUBLE dbVelo	= m_edt_flt[1].GetTextToDouble();
	ENG_MMDI enDrvID= GetSelectDrvID();
	DOUBLE dbRealPos= uvCmn_MC2_GetDrvAbsPos(enDrvID);
	if (dbDist != 0.0f && enDrvID != ENG_MMDI::en_axis_none && dbRealPos != 0.0f)
	{
		if (!uvEng_MC2_SendDevAbsMove(enDrvID, dbRealPos+dbDist, dbVelo))
		{
			AfxMessageBox(L"Failed to move the motion to the set position", MB_ICONSTOP);
		}
	}
}

/*
 desc : Returns the number of the drive checked
 parm : None
 retn : Driver ID
*/
ENG_MMDI CDlgMain::GetSelectDrvID()
{
	UINT8 i	= 0x00, u8DrvNo = 0xff;

	/* 현재 위치에서 이동 거리 값이 Min or Max 값을 초과 했다면, Min or Max 값 만큼 이동 */
	for (i=0; i<uvEng_GetConfig()->mc2_svc.drive_count && u8DrvNo == 0xff; i++)
	{
		if (!m_chk_ctl[u8DrvNo].GetCheck())	continue;
		u8DrvNo	= uvEng_GetConfig()->mc2_svc.axis_id[i];
		break;
	}

	return ENG_MMDI(u8DrvNo);
}

/*
 desc : Move the motion drive
 parm : direct	- [in]  Up (or left) or Down (or right)
 retn : None
*/
VOID CDlgMain::MotionMove(ENG_MDMD direct)
{
	UINT8 i	= 0x00, u8DrvNo = 0x00;	/* 0x00 ~ 0x07 */
	BOOL bCheck		= FALSE;
	DOUBLE dbDrvPos	= 0, dbMinPos, dbMaxPos, dbDist, dbVelo;
	LPG_CMSI pstCfg	= &uvEng_GetConfig()->mc2_svc;
	LPG_MDSM pstMC2	= uvEng_ShMem_GetMC2();

	/* 이동하고자 하는 Drive가 체크 되어 있는지 확인 */
	for (i=0; i<pstCfg->drive_count && !bCheck; i++)
	{
		bCheck	= m_chk_ctl[pstCfg->axis_id[i]].GetCheck() > 0;
	}
	if (!bCheck)
	{
		AfxMessageBox(L"The drive to be moved is not checked", MB_ICONSTOP|MB_TOPMOST);
		return;
	}
	/* 이동하고자 하는 속도와 거리 값이 입력되어 있는지 확인 (여기서는 Step 이동만 해당 됨) */
	dbDist	= m_edt_flt[0].GetTextToDouble();
	dbVelo	= m_edt_flt[1].GetTextToDouble();
	if (dbDist < 0.0001f || dbVelo < 1.0f)
	{
		AfxMessageBox(L"Check the move distance and speed values", MB_ICONSTOP|MB_TOPMOST);
		return;
	}

	/* 현재 위치에서 이동 거리 값이 Min or Max 값을 초과 했다면, Min or Max 값 만큼 이동 */
	for (i=0; i<pstCfg->drive_count; i++)
	{
		/* 드라이브가 체크 되어 있는지 여부 확인 */
		u8DrvNo	= pstCfg->axis_id[i];
		if (!m_chk_ctl[u8DrvNo].GetCheck())	continue;

		/* 현재 드라이브의 위치 확인 */
		dbDrvPos	= uvCmn_MC2_GetDrvAbsPos(ENG_MMDI(u8DrvNo));
		dbMinPos	= pstCfg->min_dist[u8DrvNo];
		dbMaxPos	= pstCfg->max_dist[u8DrvNo];

		/* 위로 혹은 오른 쪽으로 이동하면, 기존 위치에 이동 거리 값만큼 더해 주기 */
		if (direct == ENG_MDMD::en_move_up || direct == ENG_MDMD::en_move_right)
		{
			dbDrvPos	+= dbDist;	/* 이동할 거리 값 계산 */
			if (dbDrvPos > dbMaxPos)	dbDrvPos	= dbMaxPos;	/* 최대 이동 거리 넘어가면, 최대 값으로 대체 */
		}
		else
		{
			dbDrvPos	-= dbDist;	/* 이동할 거리 값 계산 */
			if (dbDrvPos < dbMinPos)	dbDrvPos	= dbMinPos;	/* 최소 이동 거리 넘어가면, 최대 값으로 대체 */
		}

		/* Motion Drive 이동 */
		if (!uvEng_MC2_SendDevAbsMove(ENG_MMDI(u8DrvNo), dbDrvPos, dbVelo))
		{
			AfxMessageBox(L"Failed to move the motion drive", MB_ICONSTOP|MB_TOPMOST);
			return;
		}
	}
}

/*
 desc : Move the Z motor drive
 parm : direct	- [in]  Up or Down
 retn : None
*/
VOID CDlgMain::ZMotorMove(ENG_MDMD direct)
{
	DOUBLE dbPosZ	= 0.0f;	/* unit : mm */

	/* Get the distance value to move */
	dbPosZ	= m_edt_flt[9].GetTextToDouble();
	if (ENG_MDMD::en_move_up != direct)	dbPosZ *= -1.0f;
	/* Get the Z-axis value of current align camera */
	dbPosZ	+= uvCmn_MCQ_GetACamCurrentPosZ(GetCheckACam());
	/* 새로운 위치로 이동 */
	uvEng_MCQ_SetACamMovePosZ(GetCheckACam(), 0x00 /* Absolute Moving */, dbPosZ);
}

/*
 desc : MC2의 모든 Motor 초기화 (복구) (Homing)
 parm : None
 retn : None
*/
VOID CDlgMain::MC2Recovery()
{
	UINT8 i	= 0x00;
#if 1
	for (i=0; i<MAX_MC2_DRIVE; i++)
	{
		if (!m_chk_ctl[i].GetCheck())	continue;
		if (!uvEng_MC2_SendDevHoming(ENG_MMDI(i)))
		{
			AfxMessageBox(L"The home operation of all drives has failed", MB_ICONSTOP|MB_TOPMOST);
			return;
		}
	}
#else
	if (!uvEng_MC2_SendDevHomingAll())
	{
		AfxMessageBox(L"The home operation of all drives has failed", MB_ICONSTOP|MB_TOPMOST);
		return;
	}
#endif
}

/*
 desc : Save the data in the grid control to a file
 parm : None
 retn : None
*/
VOID CDlgMain::SaveAsExcelFile()
{
	TCHAR tzTempFile[MAX_PATH_LEN]	= {NULL};
	SYSTEMTIME stTm	= {NULL};

	/* Get the current time */
	GetLocalTime(&stTm);

	/* 등록된 데이터가 없는지 확인 */
	if (m_pGridResult->GetRowCount() < 2)	return;

	/* 윈도 임시 파일로 저장 후 열기 */
	swprintf_s(tzTempFile, MAX_PATH_LEN, L"%s\\hole\\size_acam(%u)_thick(%u)_%04d%02d%02d_%02d%02d.csv",
			   g_tzWorkDir, GetCheckACam(), (UINT16)m_edt_int[2].GetTextToNum(),
			   stTm.wYear, stTm.wMonth, stTm.wDay, stTm.wHour, stTm.wMinute);
	m_pGridResult->Save(tzTempFile);
}

/*
 desc : Move the stage to the operator position
 parm : None
 retn : None
*/
VOID CDlgMain::UnloadPosition()
{
	DOUBLE dbMoveX	= uvEng_GetConfig()->set_align.table_unloader_xy[0][0];
	DOUBLE dbMoveY	= uvEng_GetConfig()->set_align.table_unloader_xy[0][1];

	/* Controls the Vacuum and Shutter at the same time */
	uvEng_MCQ_LedVacuumShutter(0x00, 0x01, 0x00);
	/* Move the stages */
	uvEng_MC2_SendDevAbsMove(ENG_MMDI::en_stage_x, dbMoveX, m_edt_flt[1].GetTextToDouble());
	uvEng_MC2_SendDevAbsMove(ENG_MMDI::en_stage_y, dbMoveY, m_edt_flt[1].GetTextToDouble());
}

/*
 desc : Enable or Disable of various controls
 parm : None
 retn : None
*/
VOID CDlgMain::EnableCtrl()
{
	UINT8 i;
	BOOL bStopped	= TRUE, bIsLive	= m_chk_ctl[8].GetCheck() == 0 ? TRUE : FALSE;
	BOOL bConnected	= TRUE, bEnable	= TRUE, bIsDemo = uvEng_GetConfig()->IsRunDemo();
	LPG_CMSI pstMC2Svc	= &uvEng_GetConfig()->mc2_svc;

	/* Check whether the devices are connected */
	bConnected	= uvCmn_MC2_IsConnected() && uvCmn_Camera_IsConnected() &&
				  uvCmn_Trig_IsConnected();
	/* Check whether the motion is busy */
	bStopped	= uvEng_ShMem_GetMC2()->GetDriveAct((UINT8)ENG_MMDI::en_stage_x)->IsStopped()	&&
				  uvEng_ShMem_GetMC2()->GetDriveAct((UINT8)ENG_MMDI::en_stage_y)->IsStopped()	&&
				  uvEng_ShMem_GetMC2()->GetDriveAct((UINT8)ENG_MMDI::en_align_cam1)->IsStopped()&&
				  uvEng_ShMem_GetMC2()->GetDriveAct((UINT8)ENG_MMDI::en_align_cam2)->IsStopped();

	/* Determine the active conditions for the control */
	bEnable	= bStopped && bConnected || bIsDemo;

	/* for checkbox */
	for (i=0; i<10; i++)
	{
		if (m_chk_ctl[i].IsWindowEnabled() == bEnable)	continue;
		m_chk_ctl[i].EnableWindow(bEnable);
	}
	/* for button */
	for (i=1; i<13; i++)
	{
		if (i == 9 || i == 12)
		{
			if (!bIsLive)	m_btn_ctl[i].EnableWindow(FALSE);
			else
			{
				if (m_u8GrabbedMode == 0x01)
				{
					m_btn_ctl[9].EnableWindow(TRUE);
//					m_btn_ctl[12].EnableWindow(FALSE);
				}
				else if (m_u8GrabbedMode == 0x00 || m_u8GrabbedMode == 0x02)
				{
					m_btn_ctl[9].EnableWindow(FALSE);
//					m_btn_ctl[12].EnableWindow(TRUE);
				}
			}
			continue;
		}
		m_btn_ctl[i].EnableWindow(bEnable);
	}
	/* for edit */
	for (i=0; i<8; i++)
	{
		if (m_edt_flt[i].IsWindowEnabled() == bEnable)	continue;
		m_edt_flt[i].EnableWindow(bEnable);
	}
	for (i=0; i<3; i++)
	{
		if (m_edt_int[i].IsWindowEnabled() == bEnable)	continue;
		m_edt_int[i].EnableWindow(bEnable);
	}
}

/*
desc : Get the grabbed image
parm : None
retrn : None
*/
VOID CDlgMain::GetGrabbedImage()
{
	UINT8 u8ACamID		= GetCheckACam();
	BOOL bFinded		= FALSE;
	UINT64 u64TickLoop	= 0, u64StartTick;
	LPG_ACGR pstResult	= NULL;

	/* Reset the flag */
	m_u8GrabbedMode	= 0x00;

	/* 기존 검색된 Grabbed Data & Image 제거 */
	uvEng_Camera_ResetGrabbedImage();

	if (!uvEng_GetConfig()->IsRunDemo())
	{
		/* 작업 요청 대기 시간 */
		u64StartTick	= GetTickCount64();
		/* Trigger 강제로 (수동으로) 발생 */
		if (!uvEng_Trig_ReqTrigOutOne(u8ACamID, TRUE))
		{
			AfxMessageBox(L"Failed to send the event for trigger", MB_ICONSTOP|MB_TOPMOST);
		}
		else
		{
			/* 작업 요청 대기 시간 */
			u64StartTick	= GetTickCount64();
			/* 1 ~ 2 초 정도 대기 */
			do {

				if (u64StartTick+2000 < GetTickCount64())	break;
				uvCmn_uSleep(100);

			} while (1);
		}
	}
	else
	{
		TCHAR tzInit[MAX_PATH_LEN]	= {NULL};
		PTCHAR ptzFile	= (PTCHAR)::Alloc(sizeof(TCHAR)*MAX_PATH_LEN);
		wmemset(ptzFile, 0x00, MAX_PATH_LEN);
		swprintf_s(tzInit, MAX_PATH_LEN, L"%s\\hole", g_tzWorkDir);
		if (uvCmn_GetSelectFile(L"Bitmap (*.bmp) | *.bmp",
								MAX_PATH_LEN, ptzFile, L"Select the BMP File", tzInit))
		{
			uvEng_Camera_LoadImageFromFile(0x01, ptzFile);
		}
		::Free(ptzFile);
	}

	/* Set the flag */
	m_u8GrabbedMode	= 0x01;
	/* Updates the value of grabbed image*/
	InvalidateView();
}

/*
 desc : 정상적으로 동작하는지 매칭 확인
 parm : None
 반화 : None
*/
VOID CDlgMain::RunMeasMatch()
{
	STG_MSMP stParam	= {NULL};
	STG_MSMR stResult	= {NULL};

	/* 이전에 수집된 이미지가 있는지 여부 */
	if (m_u8GrabbedMode != 0x01)
	{
		AfxMessageBox(L"No images were captured.", MB_ICONSTOP);
		return;
	}

	/* 검색 결과 확인 */
	if (!ApplyOption(stParam, TRUE))	return;
	if (!uvEng_Camera_RunMarkerStrip(GetCheckACam(), &stParam, stResult))
	{
		AfxMessageBox(L"Failed to analyze the grabbed image", MB_ICONSTOP|MB_TOPMOST);
		return;
	}
	m_u8GrabbedMode	= 0x02;	/* Set the match mode */
	/* Update the values of grid control */
	UpdateStripXY(&stResult);

	/* 화면 갱신 */
	InvalidateView();
}

/*
 desc : Move the Z-axis of the camera by the thickness of the material in the focus position of the camera
 parm : None
 retn : Non
*/
VOID CDlgMain::SetDofFilmThick()
{
	DOUBLE dbDiffThick	= (DOUBLE)m_edt_int[2].GetTextToNum() / 1000.0f - uvEng_GetConfig()->set_align.dof_film_thick;
	DOUBLE *pdbACamFocus= uvEng_GetConfig()->acam_focus.acam_z_focus;
#if 0
	/* 50 um 이하이면 처리하지 못함 */
	if (dbSetThick < 0.05f)	return;
#endif
	/* Move the Z-axis of Align Camera */
	uvEng_MCQ_SetACamMovePosZ(0x01, 0x00, pdbACamFocus[0]+dbDiffThick);
	uvEng_MCQ_SetACamMovePosZ(0x02, 0x00, pdbACamFocus[1]+dbDiffThick);

	/* Sets the flag that the thickness value is set */
	m_bSetThick	= TRUE;
}

/*
 desc : Updates the live image
 parm : None
 retn : None
*/
VOID CDlgMain::UpdateLiveView()
{
	HDC hDC	= NULL;
	RECT rDraw;

	/* 이미지가 출력될 윈도 영역 */
	m_pic_ctl[0].GetClientRect(&rDraw);
	hDC	= ::GetDC(m_pic_ctl[0].m_hWnd);
	if (hDC)
	{
		uvEng_Camera_DrawLiveBitmap(hDC, rDraw, GetCheckACam());
		::ReleaseDC(m_pic_ctl[0].m_hWnd, hDC);
	}
}

/*
 desc : Apply the option values
 parm : param	- [out] Buffer that will be returned and stored
		show	- [in]  If an invalid value is entered, determine whether to print the message box
 retn : TRUE or FALSE
*/
BOOL CDlgMain::ApplyOption(STG_MSMP &param, BOOL show)
{
	CString strVal;

	/* Set the parameter */
	strVal	= m_pGridOption->GetItemText(1, 1);
	if (0 == strVal.Compare(L"VERTICAL"))	param.orientation	= 0x01;			/* M_ORIENTATION */
	strVal	= m_pGridOption->GetItemText(2, 1);
	if (0 == strVal.Compare(L"NEGATIVE"))	param.polarity[0]	= 0x01;			/* M_NEGATIVE (Left or Top) */
	strVal	= m_pGridOption->GetItemText(3, 1);
	if (0 == strVal.Compare(L"NEGATIVE"))	param.polarity[1]	= 0x01;			/* M_NEGATIVE (Right or Bottom) */
	param.box_origin.x	= m_pGridOption->GetItemTextToInt(4, 1);				/* Box Origin Left (x): Pixel */
	param.box_origin.y	= m_pGridOption->GetItemTextToInt(5, 1);				/* Box Origin Top (y) : Pixel */
	param.box_size.x	= m_pGridOption->GetItemTextToInt(6, 1);				/* Box Size Width     : Pixel */
	param.box_size.y	= m_pGridOption->GetItemTextToInt(7, 1);				/* Box Size Height    : Pixel */
	strVal	= m_pGridOption->GetItemText(8, 1);
	if (0 == strVal.Compare(L"ENABLE"))	param.enable_angle	= 0x01;				/* Use the angle */
	param.angle_delta	= m_pGridOption->GetItemTextToFloat(9, 1);				/* Angle delta */
	strVal	= m_pGridOption->GetItemText(10, 1);
	if (0 == strVal.Compare(L"NEAREST"))		param.angle_int_mode	= 0x00;	/* Interpolation Method */
	else if (0 == strVal.Compare(L"BILINEAR"))	param.angle_int_mode	= 0x01;
	else										param.angle_int_mode	= 0x02;
	param.edge_width	= m_pGridOption->GetItemTextToInt(11, 1);				/* Edge Width (Length) : Pixel */
	param.edge_offset	= m_pGridOption->GetItemTextToInt(12, 1);				/* Edge Offset (Length) : Pixel */

	/* Check whether the value is set normally */
	if (show && !param.IsVald())
	{
		AfxMessageBox(L"The set value of parameter is not valid ", MB_TOPMOST|MB_ICONSTOP);
		return FALSE;
	}

	return TRUE;
}

/*
 desc : Load the default value
 parm : None
 retn : None
*/
VOID CDlgMain::LoadDefault()
{
	INT32 i32SizeX	= uvEng_GetConfig()->set_cams.hol_size[0] / 2;
	INT32 i32SizeY	= uvEng_GetConfig()->set_cams.hol_size[1] / 2;
	m_edt_int[0].SetTextToNum(uvEng_GetConfig()->set_cams.hol_size[0]);
	m_edt_int[1].SetTextToNum(uvEng_GetConfig()->set_cams.hol_size[0]);
	m_edt_int[2].SetTextToNum(UINT16(960));

	m_edt_flt[0].SetTextToNum(10.0f, 4);
	m_edt_flt[1].SetTextToNum(100.0f, 4);
	m_edt_flt[7].SetTextToNum(0.015f, 4);

	/* Set the grid option */
	m_pGridOption->SetItemText(1, 1, L"VERTICAL");
	m_pGridOption->SetItemText(2, 1, L"NEGATIVE");	/* Negative : 밝은 곳에서 어두운 곳 찾기 */
	m_pGridOption->SetItemText(3, 1, L"POSITIVE");	/* Positive : 어두운 곳에서 밝은 곳 찾기 */
	m_pGridOption->SetItemText(6, 1, 80);
	m_pGridOption->SetItemText(7, 1, 80);
	m_pGridOption->SetItemText(4, 1, i32SizeX - m_pGridOption->GetItemTextToInt(6, 1) / 2);
	m_pGridOption->SetItemText(5, 1, i32SizeY - m_pGridOption->GetItemTextToInt(7, 1) / 2);
	m_pGridOption->SetItemText(8, 1, L"DISABLE");
	m_pGridOption->SetItemText(9, 1, 0.0f, 4);
	m_pGridOption->SetItemText(10,1, L"BILINEAR");
	m_pGridOption->SetItemText(11,1, 25);
	m_pGridOption->SetItemText(12,1, 10);
}

/*
 desc : updates the values of grid control
 parm : result	- [in]  Structure pointer which the result values are stored
 retn : None
*/
VOID CDlgMain::UpdateStripXY(LPG_MSMR result)
{
	INT32 i32Item	= m_pGridResult->GetRowCount();
	DOUBLE dbPxToUm	= uvEng_GetConfig()->acam_spec.GetPixelToMM(GetCheckACam()-1);
	/* Get the current motion position (location) */
	DOUBLE dbStageX	= uvCmn_MC2_GetDrvAbsPos(ENG_MMDI::en_stage_x);
	DOUBLE dbStageY	= uvCmn_MC2_GetDrvAbsPos(ENG_MMDI::en_stage_y);
	DOUBLE dbACamX	= uvCmn_MC2_GetDrvAbsPos(ENG_MMDI::en_stage_y);
	GV_ITEM stGV	= { NULL };

	/* Set the common properties of grid control */
	stGV.mask	= GVIF_TEXT | GVIF_FORMAT | GVIF_BKCLR | GVIF_FGCLR;
	stGV.crFgClr= RGB(0, 0, 0);
	stGV.crBkClr= RGB(252, 252, 252);
	stGV.row	= i32Item;

	/* Disable the update */
	m_pGridResult->SetRedraw(FALSE);
	/* Increase the number of row items */
	m_pGridResult->SetRowCount(i32Item+1);

	TCHAR tzTitle[7][16]= { L"No", L"Stage.X (mm)", L"Stage.Y (mm)", L"ACam.X (mm)",
							L"Angle (°)", L"Size (mm)", L"Length (mm)" };
	/* Set the value of No. */
	stGV.nFormat= DT_CENTER | DT_VCENTER | DT_SINGLELINE;
	stGV.col	= 0;
	stGV.strText.Format(L"%2d", i32Item);
	m_pGridResult->SetItem(&stGV);

	stGV.nFormat = DT_RIGHT | DT_VCENTER | DT_SINGLELINE;
	/* Set the value of Motion Position */
	stGV.col	= 1;	stGV.strText.Format(L"%.4f", dbStageX);						m_pGridResult->SetItem(&stGV);
	/* Set the value of Motion Position */
	stGV.col	= 2;	stGV.strText.Format(L"%.4f", dbStageY);						m_pGridResult->SetItem(&stGV);
	/* Set the value of Motion Position */
	stGV.col	= 3;	stGV.strText.Format(L"%.4f", dbACamX);						m_pGridResult->SetItem(&stGV);
	/* Set the value of Strip's center */
	stGV.col	= 4;	stGV.strText.Format(L"%.4f", result->cent_x * dbPxToUm);	m_pGridResult->SetItem(&stGV);
	stGV.col	= 5;	stGV.strText.Format(L"%.4f", result->cent_y * dbPxToUm);	m_pGridResult->SetItem(&stGV);
	/* Set the value of rotation angle (degree) */
	stGV.col	= 6;	stGV.strText.Format(L"%.4f", result->angle);				m_pGridResult->SetItem(&stGV);
	/* Set the value of object width (size) */
	stGV.col	= 7;	stGV.strText.Format(L"%.4f", result->width * dbPxToUm);		m_pGridResult->SetItem(&stGV);
	/* Set the value of object length (size) */
	stGV.col	= 8;	stGV.strText.Format(L"%.4f", result->length * dbPxToUm);	m_pGridResult->SetItem(&stGV);

	/* Enable the update */
	m_pGridResult->SetRedraw(TRUE, TRUE);
	m_pGridResult->InvalidateRow(i32Item);
}

/*
 desc : Reset the result data of grid control
 parm : None
 retn : None
*/
VOID CDlgMain::SetResultReset()
{
	m_pGridResult->DeleteNonFixedRows();
	m_pGridResult->Invalidate(TRUE);
}

/* 
 desc : Destroy the existing child dialog
 parm : None
 retn : None
*/
VOID CDlgMain::DestroyChild()
{
	if (m_pDlgIVal)
	{
		m_pDlgIVal->DestroyWindow();
		delete m_pDlgIVal;
		m_pDlgIVal	= NULL;
	}
}

/*
 desc : Left mouse button clicked
 parm : flags	- [in]  Indicates whether the various virtual keys are down
						This parameter can be a combination of the following values:
		point	- [in]  Specifies the x and y coordinates of the cursor
						These coordinates are always based on the upper left corner of the window
 retn : None
*/
VOID CDlgMain::OnLButtonDown(UINT32 flags, CPoint point)
{
	DOUBLE dbPixelX	= 0.0f, dbPixelY = 0.0f;
 	DOUBLE dbWidth	= m_pGridOption->GetItemTextToInt(6, 1);
 	DOUBLE dbHeight	= m_pGridOption->GetItemTextToInt(7, 1);
	CRect rDraw;

	/* */
	m_pic_ctl[0].GetWindowRect(rDraw);
	ScreenToClient(rDraw);
	/* Whether the mouse click is within the image output area */
	if (!rDraw.PtInRect(point))	return;

	/* Calculates the size ratio of the image and the output area */
	dbPixelX = uvEng_GetConfig()->set_cams.hol_size[0] / (rDraw.Width()*1.0f);
	dbPixelY = uvEng_GetConfig()->set_cams.hol_size[1] / (rDraw.Height()*1.0f);

	/* Update the start position of red box */
	INT32 i32OriginX = (INT32)ROUNDED((point.x - rDraw.left) * dbPixelX - dbWidth / 2.0f, 0);
	INT32 i32OriginY = (INT32)ROUNDED((point.y - rDraw.top) * dbPixelY - dbHeight / 2.0f, 0);
	m_pGridOption->SetItemText(4, 1, i32OriginX);	m_pGridOption->InvalidateRowCol(4, 1);
	m_pGridOption->SetItemText(5, 1, i32OriginY);	m_pGridOption->InvalidateRowCol(5, 1);
	/* Update the draw area of grabbed image */
	InvalidateView();
}